; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\gd32f10x_fmc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gd32f10x_fmc.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\startup -I..\..\cmsis-core -I..\src -I..\..\GIGA32\inc -I..\..\GIGA32\src -I..\..\GIGA32\gd32\peripherals\inc -I..\..\GIGA32\gd32\peripherals\src -I.\RTE\_Target_1 -IF:\software\mdk\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\software\mdk\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD -DDAPLINK_VERSION=242 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DINTERFACE_GD32F103 -DCPU_GD32F103CBT6 -DDAPLINK_HIC_ID=0x97969905 -DBL_TARGET_FLASH -DUSE_STDPERIPH_DRIVER -DGD32F10X_MD -DUSE_HSE_16MHZ --omf_browse=.\objects\gd32f10x_fmc.crf ..\..\GIGA32\gd32\peripherals\src\gd32f10X_fmc.c]
                          THUMB

                          AREA ||i.FMC_B1_WaitReady||, CODE, READONLY, ALIGN=1

                  FMC_B1_WaitReady PROC
;;;1231     */
;;;1232   FMC_State FMC_B1_WaitReady(uint32_t uCount)
000000  b500              PUSH     {lr}
;;;1233   { 
000002  4603              MOV      r3,r0
                  |L1.4|
;;;1234       FMC_State temp_state = FMC_BSY;
;;;1235     
;;;1236       /* Wait for FMC ready */
;;;1237       do
;;;1238       {
;;;1239           /* Get FMC state */
;;;1240           temp_state = FMC_GetB1State();
000004  f7fffffe          BL       FMC_GetB1State
000008  1e5b              SUBS     r3,r3,#1
;;;1241           uCount--;
;;;1242       }while((temp_state == FMC_BSY) && (uCount != 0x00));
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L1.20|
00000e  2b00              CMP      r3,#0
000010  d1f8              BNE      |L1.4|
;;;1243     
;;;1244       if(temp_state == FMC_BSY)
;;;1245       {
;;;1246           temp_state = FMC_TIMEOUT_ERR;
000012  2004              MOVS     r0,#4
                  |L1.20|
;;;1247       }
;;;1248       /* Return the FMC state */
;;;1249       return temp_state;
;;;1250   }
000014  bd00              POP      {pc}
;;;1251   
                          ENDP


                          AREA ||i.FMC_ClearBitState||, CODE, READONLY, ALIGN=2

                  FMC_ClearBitState PROC
;;;1072     */
;;;1073   void FMC_ClearBitState(uint32_t FMC_FLAG)
000000  4901              LDR      r1,|L2.8|
;;;1074   {
;;;1075   #if defined GD32F10X_XD || defined GD32F10X_CL
;;;1076   
;;;1077       if((FMC_FLAG & 0x80000000) != 0x0)
;;;1078       {
;;;1079           /* Clear the flags */
;;;1080           FMC->CSR2 = FMC_FLAG;
;;;1081       }
;;;1082       else
;;;1083       {
;;;1084           /* Clear the flags */
;;;1085           FMC->CSR = FMC_FLAG;
;;;1086       }  
;;;1087   
;;;1088   #else  /* Clear the flags */
;;;1089       FMC->CSR = FMC_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;1090   #endif
;;;1091   }
000004  4770              BX       lr
;;;1092   
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x40022000

                          AREA ||i.FMC_ErasePage||, CODE, READONLY, ALIGN=2

                  FMC_ErasePage PROC
;;;167      */
;;;168    FMC_State FMC_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;169    {    
000002  4605              MOV      r5,r0
;;;170    #if defined GD32F10X_XD || defined GD32F10X_CL
;;;171        FMC_State temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);
;;;172        if(Page_Address < FMC_B1_END_ADDRESS)  
;;;173        {
;;;174            /* Wait for last operation to be completed */
;;;175            FMC_State temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);
;;;176      
;;;177            if(temp_state == FMC_READY)
;;;178            { 
;;;179                FMC->CMR |= FMC_CMR_PE;
;;;180                FMC->AR  = Page_Address;
;;;181                FMC->CMR |= FMC_CMR_START;
;;;182        
;;;183                /* Wait for the FMC ready */
;;;184                temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);
;;;185        
;;;186                /* Reset the PE bit */
;;;187                FMC->CMR &= ~FMC_CMR_PE;
;;;188            }
;;;189        }
;;;190        else
;;;191        {
;;;192            /* Wait for last operation to be completed */
;;;193            FMC_State temp_state = FMC_B2_WaitReady(FMC_TIMEOUT_COUNT);
;;;194      
;;;195            if(temp_state == FMC_READY)
;;;196            { 
;;;197                FMC->CMR2 |= FMC_CMR_PE;
;;;198                FMC->AR2  = Page_Address;
;;;199                FMC->CMR2 |= FMC_CMR_START;
;;;200        
;;;201                /* Wait for the FMC ready */
;;;202                temp_state = FMC_B2_WaitReady(FMC_TIMEOUT_COUNT);
;;;203        
;;;204                /* Reset the PE bit */
;;;205                FMC->CMR2 &= ~FMC_CMR_PE;
;;;206            }
;;;207        }
;;;208    #else
;;;209        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000004  f44f2670          MOV      r6,#0xf0000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FMC_WaitReady
;;;210      
;;;211        if(temp_state == FMC_READY)
00000e  2800              CMP      r0,#0
000010  d110              BNE      |L3.52|
;;;212        { 
;;;213            /* Start page erase */
;;;214            FMC->CMR |= FMC_CMR_PE;
000012  4c09              LDR      r4,|L3.56|
000014  6920              LDR      r0,[r4,#0x10]
000016  f0400002          ORR      r0,r0,#2
00001a  6120              STR      r0,[r4,#0x10]
;;;215            FMC->AR  = Page_Address;
00001c  6165              STR      r5,[r4,#0x14]
;;;216            FMC->CMR |= FMC_CMR_START;
00001e  6920              LDR      r0,[r4,#0x10]
000020  f0400040          ORR      r0,r0,#0x40
000024  6120              STR      r0,[r4,#0x10]
;;;217        
;;;218            /* Wait for the FMC ready */
;;;219            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       FMC_WaitReady
;;;220        
;;;221            /* Reset the PE bit */
;;;222            FMC->CMR &= ~FMC_CMR_PE;
00002c  6921              LDR      r1,[r4,#0x10]
00002e  f0210102          BIC      r1,r1,#2
000032  6121              STR      r1,[r4,#0x10]
                  |L3.52|
;;;223        }
;;;224    #endif
;;;225        /* Return the FMC state  */
;;;226        return temp_state;
;;;227    }
000034  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      0x40022000

                          AREA ||i.FMC_GetB1State||, CODE, READONLY, ALIGN=2

                  FMC_GetB1State PROC
;;;1133     */
;;;1134   FMC_State FMC_GetB1State(void)
000000  4908              LDR      r1,|L4.36|
;;;1135   {
;;;1136       FMC_State temp_state = FMC_READY;
000002  2000              MOVS     r0,#0
;;;1137     
;;;1138       if((FMC->CSR & FMC_CSR_BUSY) == FMC_CSR_BUSY) 
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L4.14|
;;;1139       {
;;;1140           temp_state = FMC_BSY;
00000a  2001              MOVS     r0,#1
;;;1141       }
;;;1142       else 
;;;1143       {  
;;;1144           if((FMC->CSR & (uint32_t)FMC_CSR_WPEF)!= (uint32_t)0x00)
;;;1145           { 
;;;1146               temp_state = FMC_WRPERR;
;;;1147           }
;;;1148           else 
;;;1149           {
;;;1150               if((FMC->CSR & (uint32_t)(FMC_CSR_PGEF)) != (uint32_t)0x00)
;;;1151               {
;;;1152                   temp_state = FMC_PGERR; 
;;;1153               }
;;;1154               else
;;;1155               {
;;;1156                   temp_state = FMC_READY;
;;;1157               }
;;;1158           }
;;;1159       }
;;;1160       return temp_state;
;;;1161   }
00000c  4770              BX       lr
                  |L4.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;1144
000010  06d2              LSLS     r2,r2,#27             ;1144
000012  d501              BPL      |L4.24|
000014  2002              MOVS     r0,#2                 ;1146
                  |L4.22|
000016  4770              BX       lr
                  |L4.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;1150
00001a  0749              LSLS     r1,r1,#29             ;1150
00001c  d5fb              BPL      |L4.22|
00001e  2003              MOVS     r0,#3                 ;1152
000020  4770              BX       lr
;;;1162   
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x40022000

                          AREA ||i.FMC_GetBitState||, CODE, READONLY, ALIGN=2

                  FMC_GetBitState PROC
;;;996      */
;;;997    TypeState FMC_GetBitState(uint32_t FMC_FLAG)
000000  4906              LDR      r1,|L5.28|
;;;998    {
;;;999    #if defined GD32F10X_XD || defined GD32F10X_CL
;;;1000     /* Check the parameters */
;;;1001       if(FMC_FLAG == FMC_FLAG_OPTERR) 
;;;1002       {
;;;1003           if((FMC->OPTR & FMC_FLAG_OPTERR) != (uint32_t)RESET)
;;;1004           {
;;;1005               return SET;
;;;1006           }
;;;1007           else
;;;1008           {
;;;1009               return RESET;
;;;1010           }
;;;1011       }
;;;1012       else
;;;1013       {
;;;1014           if((FMC_FLAG & 0x80000000) != 0x0)
;;;1015           {
;;;1016               if((FMC->CSR2 & FMC_FLAG) != (uint32_t)RESET)
;;;1017               {
;;;1018                   return SET;
;;;1019               }
;;;1020               else
;;;1021               {
;;;1022                   return RESET;
;;;1023               }
;;;1024           }
;;;1025           else
;;;1026           {
;;;1027               if((FMC->CSR & FMC_FLAG) != (uint32_t)RESET)
;;;1028               {
;;;1029                   return SET;
;;;1030               }
;;;1031               else
;;;1032               {
;;;1033                   return RESET;
;;;1034               }
;;;1035           }
;;;1036       }
;;;1037   #else
;;;1038       if(FMC_FLAG == FMC_FLAG_OPTERR) 
000002  2801              CMP      r0,#1
000004  d004              BEQ      |L5.16|
;;;1039       {
;;;1040           if((FMC->OPTR & FMC_FLAG_OPTERR) != (uint32_t)RESET)
;;;1041           {
;;;1042               return SET;
;;;1043           }
;;;1044           else
;;;1045           {
;;;1046               return RESET;
;;;1047           }
;;;1048       }
;;;1049       else
;;;1050       {
;;;1051           if((FMC->CSR & FMC_FLAG) != (uint32_t)RESET)
000006  68c9              LDR      r1,[r1,#0xc]
000008  4201              TST      r1,r0
00000a  d005              BEQ      |L5.24|
                  |L5.12|
;;;1052           {
;;;1053               return  SET;
00000c  2001              MOVS     r0,#1
;;;1054           }
;;;1055           /* Return the state of corresponding FMC flag */
;;;1056           else
;;;1057           {
;;;1058               return RESET;
;;;1059           }
;;;1060       } 
;;;1061   #endif
;;;1062   }
00000e  4770              BX       lr
                  |L5.16|
000010  69c8              LDR      r0,[r1,#0x1c]         ;1040
000012  07c0              LSLS     r0,r0,#31             ;1040
000014  d1fa              BNE      |L5.12|
000016  4770              BX       lr
                  |L5.24|
000018  2000              MOVS     r0,#0                 ;1058
00001a  4770              BX       lr
;;;1063   
                          ENDP

                  |L5.28|
                          DCD      0x40022000

                          AREA ||i.FMC_GetState||, CODE, READONLY, ALIGN=2

                  FMC_GetState PROC
;;;1097     */
;;;1098   FMC_State FMC_GetState(void)
000000  4908              LDR      r1,|L6.36|
;;;1099   {
;;;1100       FMC_State temp_state = FMC_READY;
000002  2000              MOVS     r0,#0
;;;1101     
;;;1102       if((FMC->CSR & FMC_CSR_BUSY) == FMC_CSR_BUSY) 
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L6.14|
;;;1103       {
;;;1104           temp_state = FMC_BSY;
00000a  2001              MOVS     r0,#1
;;;1105       }
;;;1106       else 
;;;1107       {  
;;;1108           if((FMC->CSR & (uint32_t)FMC_CSR_WPEF)!= (uint32_t)0x00)
;;;1109           { 
;;;1110               temp_state = FMC_WRPERR;
;;;1111           }
;;;1112           else 
;;;1113           {
;;;1114               if((FMC->CSR & (uint32_t)(FMC_CSR_PGEF)) != (uint32_t)0x00)
;;;1115               {
;;;1116                   temp_state = FMC_PGERR; 
;;;1117               }
;;;1118               else
;;;1119               {
;;;1120                   temp_state = FMC_READY;
;;;1121               }
;;;1122           }
;;;1123       }
;;;1124   
;;;1125       /* Return the FMC state */
;;;1126       return temp_state;
;;;1127   }
00000c  4770              BX       lr
                  |L6.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;1108
000010  06d2              LSLS     r2,r2,#27             ;1108
000012  d501              BPL      |L6.24|
000014  2002              MOVS     r0,#2                 ;1110
                  |L6.22|
000016  4770              BX       lr
                  |L6.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;1114
00001a  0749              LSLS     r1,r1,#29             ;1114
00001c  d5fb              BPL      |L6.22|
00001e  2003              MOVS     r0,#3                 ;1116
000020  4770              BX       lr
;;;1128   
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40022000

                          AREA ||i.FMC_INTConfig||, CODE, READONLY, ALIGN=2

                  FMC_INTConfig PROC
;;;942      */
;;;943    void FMC_INTConfig(uint32_t FMC_INT, TypeState NewValue)
000000  4a04              LDR      r2,|L7.20|
;;;944    {
;;;945    #if defined GD32F10X_XD || defined GD32F10X_CL
;;;946        if((FMC_INT & 0x80000000) != 0x0)
;;;947        {
;;;948            if(NewValue != DISABLE)
;;;949            {
;;;950                /* Enable the interrupt sources */
;;;951                FMC->CMR2 |= (FMC_INT&0x7fffffff);
;;;952            }
;;;953            else
;;;954            {
;;;955                /* Disable the interrupt sources */
;;;956                FMC->CMR2 &= ~(uint32_t)(FMC_INT&0x7fffffff);
;;;957            }
;;;958        }
;;;959        else
;;;960        {    
;;;961            if(NewValue != DISABLE)
;;;962            {
;;;963                /* Enable the interrupt sources */
;;;964                FMC->CMR |= FMC_INT;
;;;965            }
;;;966            else
;;;967            {
;;;968                /* Disable the interrupt sources */
;;;969                FMC->CMR &= ~(uint32_t)FMC_INT;
;;;970            }
;;;971        }
;;;972    #else
;;;973        if(NewValue != DISABLE)
000002  2900              CMP      r1,#0
;;;974        {
;;;975            /* Enable the interrupt sources */
;;;976            FMC->CMR |= FMC_INT;
;;;977        }
;;;978        else
;;;979        {
;;;980            /* Disable the interrupt sources */
;;;981            FMC->CMR &= ~(uint32_t)FMC_INT;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L7.12|
000008  4301              ORRS     r1,r1,r0              ;976
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4381              BICS     r1,r1,r0
                  |L7.14|
00000e  6111              STR      r1,[r2,#0x10]         ;976
;;;982        }
;;;983    #endif
;;;984    }
000010  4770              BX       lr
;;;985    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40022000

                          AREA ||i.FMC_Lock||, CODE, READONLY, ALIGN=2

                  FMC_Lock PROC
;;;123      */
;;;124    void FMC_Lock(void)
000000  4802              LDR      r0,|L8.12|
;;;125    {
;;;126        /* Set the LOCK bit*/
;;;127        FMC->CMR |= FMC_CMR_LK;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;128    #if defined GD32F10X_XD || defined GD32F10X_CL
;;;129        /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;130        FMC->CMR2 |= FMC_CMR_LK;
;;;131    #endif /* GD32F10X_XL */
;;;132    }
00000a  4770              BX       lr
;;;133    
                          ENDP

                  |L8.12|
                          DCD      0x40022000

                          AREA ||i.FMC_LockB1||, CODE, READONLY, ALIGN=2

                  FMC_LockB1 PROC
;;;142      */
;;;143    void FMC_LockB1(void)
000000  4802              LDR      r0,|L9.12|
;;;144    {
;;;145        /* Set the Lock Bit to lock the FPEC and the CMR of  Bank1 */
;;;146        FMC->CMR |= FMC_CMR_LK;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;147    }
00000a  4770              BX       lr
;;;148    
                          ENDP

                  |L9.12|
                          DCD      0x40022000

                          AREA ||i.FMC_MassB1Erase||, CODE, READONLY, ALIGN=2

                  FMC_MassB1Erase PROC
;;;292      */
;;;293    FMC_State FMC_MassB1Erase(void)
000000  b530              PUSH     {r4,r5,lr}
;;;294    {
;;;295        FMC_State temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);
000002  f44f2570          MOV      r5,#0xf0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FMC_B1_WaitReady
;;;296      
;;;297        if(temp_state == FMC_READY)
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L10.48|
;;;298        {
;;;299            /* Start chip erase */
;;;300            FMC->CMR |= FMC_CMR_ME;
000010  4c08              LDR      r4,|L10.52|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;301            FMC->CMR |= FMC_CMR_START;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;302        
;;;303            /* Wait for the FMC ready */
;;;304            temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT); 
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       FMC_B1_WaitReady
;;;305    
;;;306            /* Reset the MER bit */
;;;307            FMC->CMR &= ~FMC_CMR_ME;
000028  6921              LDR      r1,[r4,#0x10]
00002a  f0210104          BIC      r1,r1,#4
00002e  6121              STR      r1,[r4,#0x10]
                  |L10.48|
;;;308        }
;;;309        /* Return the Erase Status */
;;;310        return temp_state;
;;;311    }
000030  bd30              POP      {r4,r5,pc}
;;;312    
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40022000

                          AREA ||i.FMC_MassErase||, CODE, READONLY, ALIGN=2

                  FMC_MassErase PROC
;;;233      */
;;;234    FMC_State FMC_MassErase(void)
000000  b530              PUSH     {r4,r5,lr}
;;;235    {
;;;236    #if defined GD32F10X_XD || defined GD32F10X_CL
;;;237        /* Wait for last operation to be completed */
;;;238        FMC_State temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);
;;;239        if(temp_state == FMC_READY)
;;;240        {
;;;241            /* Start chip erase */
;;;242            FMC->CMR |= FMC_CMR_ME;
;;;243            FMC->CMR |= FMC_CMR_START;    
;;;244        
;;;245            /* Wait for the FMC ready */
;;;246            temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);
;;;247    
;;;248            /* Reset the MER bit */
;;;249            FMC->CMR &= ~FMC_CMR_ME;
;;;250        }  
;;;251        temp_state = FMC_B2_WaitReady(FMC_TIMEOUT_COUNT);
;;;252        if(temp_state == FMC_READY)
;;;253        {
;;;254            /* Start chip erase */
;;;255            FMC->CMR2 |= FMC_CMR_ME;
;;;256            FMC->CMR2 |= FMC_CMR_START;    
;;;257        
;;;258            /* Wait for the FMC ready */
;;;259            temp_state = FMC_B2_WaitReady(FMC_TIMEOUT_COUNT);
;;;260    
;;;261            /* Reset the MER bit */
;;;262            FMC->CMR2 &= ~FMC_CMR_ME;
;;;263        } 
;;;264    #else
;;;265        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000002  f44f2570          MOV      r5,#0xf0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FMC_WaitReady
;;;266      
;;;267        if(temp_state == FMC_READY)
00000c  2800              CMP      r0,#0
00000e  d10f              BNE      |L11.48|
;;;268        {
;;;269            /* Start chip erase */
;;;270            FMC->CMR |= FMC_CMR_ME;
000010  4c08              LDR      r4,|L11.52|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;271            FMC->CMR |= FMC_CMR_START;    
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;272        
;;;273            /* Wait for the FMC ready */
;;;274            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       FMC_WaitReady
;;;275    
;;;276            /* Reset the MER bit */
;;;277            FMC->CMR &= ~FMC_CMR_ME;
000028  6921              LDR      r1,[r4,#0x10]
00002a  f0210104          BIC      r1,r1,#4
00002e  6121              STR      r1,[r4,#0x10]
                  |L11.48|
;;;278        }
;;;279    #endif
;;;280        /* Return the FMC state  */
;;;281        return temp_state;
;;;282    }
000030  bd30              POP      {r4,r5,pc}
;;;283    
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40022000

                          AREA ||i.FMC_OB_BOOTConfig||, CODE, READONLY, ALIGN=2

                  FMC_OB_BOOTConfig PROC
;;;778      */
;;;779    FMC_State FMC_OB_BOOTConfig(uint8_t OB_BOOT)
000000  b570              PUSH     {r4-r6,lr}
;;;780    {
000002  4605              MOV      r5,r0
;;;781        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000004  f44f2670          MOV      r6,#0xf0000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FMC_WaitReady
;;;782        FMC->OBKEYR = FMC_KEY1;
00000e  4c10              LDR      r4,|L12.80|
000010  490e              LDR      r1,|L12.76|
000012  60a1              STR      r1,[r4,#8]
;;;783        FMC->OBKEYR = FMC_KEY2;
000014  490f              LDR      r1,|L12.84|
000016  60a1              STR      r1,[r4,#8]
;;;784    
;;;785        if(temp_state == FMC_READY)
000018  2800              CMP      r0,#0
00001a  d113              BNE      |L12.68|
;;;786        {  
;;;787            /* Set the OBPG bit*/
;;;788            FMC->CMR |= FMC_CMR_OBPG;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400010          ORR      r0,r0,#0x10
000022  6120              STR      r0,[r4,#0x10]
;;;789    
;;;790           if(OB_BOOT == OB_BOOT_B1)
;;;791           {
;;;792               OB->USER |= OB_USER_BFB2;
000024  480c              LDR      r0,|L12.88|
000026  2d08              CMP      r5,#8                 ;790
;;;793           }
;;;794           else
;;;795           {
;;;796               OB->USER &= (uint16_t)(~(uint16_t)(OB_USER_BFB2));
000028  8801              LDRH     r1,[r0,#0]
00002a  d00c              BEQ      |L12.70|
00002c  f0210108          BIC      r1,r1,#8
                  |L12.48|
000030  8001              STRH     r1,[r0,#0]
;;;797           }
;;;798    
;;;799            /* Wait for the FMC ready */
;;;800            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       FMC_WaitReady
;;;801    
;;;802            if(temp_state != FMC_TIMEOUT_ERR)
000038  2804              CMP      r0,#4
00003a  d003              BEQ      |L12.68|
;;;803            {
;;;804                /* Reset the OBPG bit */
;;;805                FMC->CMR &= ~FMC_CMR_OBPG;
00003c  6921              LDR      r1,[r4,#0x10]
00003e  f0210110          BIC      r1,r1,#0x10
000042  6121              STR      r1,[r4,#0x10]
                  |L12.68|
;;;806            }
;;;807        }
;;;808        /* Return the FMC state */
;;;809        return temp_state;
;;;810    }
000044  bd70              POP      {r4-r6,pc}
                  |L12.70|
000046  f0410108          ORR      r1,r1,#8              ;792
00004a  e7f1              B        |L12.48|
;;;811    
                          ENDP

                  |L12.76|
                          DCD      0x45670123
                  |L12.80|
                          DCD      0x40022000
                  |L12.84|
                          DCD      0xcdef89ab
                  |L12.88|
                          DCD      0x1ffff802

                          AREA ||i.FMC_OB_EnableWRP||, CODE, READONLY, ALIGN=2

                  FMC_OB_EnableWRP PROC
;;;568      */
;;;569    FMC_State FMC_OB_EnableWRP(uint32_t OB_WRP)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;570    {
000004  4604              MOV      r4,r0
;;;571        uint16_t temp_WRP0, temp_WRP1, temp_WRP2, temp_WRP3;
;;;572    
;;;573        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000006  f44f2870          MOV      r8,#0xf0000
00000a  4640              MOV      r0,r8
00000c  f7fffffe          BL       FMC_WaitReady
;;;574    
;;;575        OB_WRP = (uint32_t)(~OB_WRP);
000010  43e1              MVNS     r1,r4
;;;576        temp_WRP0 = (uint16_t)(OB_WRP & OB_WRP0_WRP0);
;;;577        temp_WRP1 = (uint16_t)((OB_WRP & OB_WRP0_nWRP0) >> 8);
;;;578        temp_WRP2 = (uint16_t)((OB_WRP & OB_WRP1_WRP1) >> 16);
;;;579        temp_WRP3 = (uint16_t)((OB_WRP & OB_WRP1_nWRP1) >> 24);
000012  0e0c              LSRS     r4,r1,#24
000014  b2ca              UXTB     r2,r1                 ;576
000016  f3c12607          UBFX     r6,r1,#8,#8           ;577
00001a  f3c14507          UBFX     r5,r1,#16,#8          ;578
;;;580    
;;;581        if(temp_state == FMC_READY)
00001e  2800              CMP      r0,#0
000020  d130              BNE      |L13.132|
;;;582        {
;;;583            FMC->OBKEYR = FMC_KEY1;
000022  4f1a              LDR      r7,|L13.140|
000024  4918              LDR      r1,|L13.136|
000026  60b9              STR      r1,[r7,#8]
;;;584            FMC->OBKEYR = FMC_KEY2;
000028  4919              LDR      r1,|L13.144|
00002a  60b9              STR      r1,[r7,#8]
;;;585            /* Set the OBPG bit*/
;;;586            FMC->CMR |= FMC_CMR_OBPG;
00002c  6939              LDR      r1,[r7,#0x10]
00002e  f0410110          ORR      r1,r1,#0x10
000032  6139              STR      r1,[r7,#0x10]
;;;587    
;;;588            if(temp_WRP0 != 0xFF)
000034  2aff              CMP      r2,#0xff
000036  d005              BEQ      |L13.68|
;;;589            {
;;;590                OB->WRP0 = temp_WRP0;
000038  4816              LDR      r0,|L13.148|
00003a  8002              STRH     r2,[r0,#0]
;;;591          
;;;592                /* Wait for the FMC ready */
;;;593                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       FMC_WaitReady
000042  b9c8              CBNZ     r0,|L13.120|
                  |L13.68|
;;;594            }
;;;595            if((temp_state == FMC_READY) && (temp_WRP1 != 0xFF))
000044  2eff              CMP      r6,#0xff
000046  d006              BEQ      |L13.86|
;;;596            {
;;;597                OB->WRP1 = temp_WRP1;
000048  4812              LDR      r0,|L13.148|
00004a  1c80              ADDS     r0,r0,#2
00004c  8006              STRH     r6,[r0,#0]
;;;598          
;;;599                /* Wait for the FMC ready */
;;;600                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       FMC_WaitReady
000054  b980              CBNZ     r0,|L13.120|
                  |L13.86|
;;;601            }
;;;602            if((temp_state == FMC_READY) && (temp_WRP2 != 0xFF))
000056  2dff              CMP      r5,#0xff
000058  d006              BEQ      |L13.104|
;;;603            {
;;;604                OB->WRP2 = temp_WRP2;
00005a  480e              LDR      r0,|L13.148|
00005c  1d00              ADDS     r0,r0,#4
00005e  8005              STRH     r5,[r0,#0]
;;;605          
;;;606                /* Wait for the FMC ready */
;;;607                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000060  4640              MOV      r0,r8
000062  f7fffffe          BL       FMC_WaitReady
000066  b938              CBNZ     r0,|L13.120|
                  |L13.104|
;;;608            }
;;;609            if((temp_state == FMC_READY) && (temp_WRP3 != 0xFF))
000068  2cff              CMP      r4,#0xff
00006a  d007              BEQ      |L13.124|
;;;610            {
;;;611                OB->WRP3 = temp_WRP3;
00006c  4809              LDR      r0,|L13.148|
00006e  1d80              ADDS     r0,r0,#6
000070  8004              STRH     r4,[r0,#0]
;;;612          
;;;613                /* Wait for the FMC ready */
;;;614                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       FMC_WaitReady
                  |L13.120|
;;;615            }
;;;616            if(temp_state != FMC_TIMEOUT_ERR)
000078  2804              CMP      r0,#4
00007a  d003              BEQ      |L13.132|
                  |L13.124|
;;;617            {
;;;618                /* Reset the OBPG bit */
;;;619                FMC->CMR &= ~FMC_CMR_OBPG;
00007c  6939              LDR      r1,[r7,#0x10]
00007e  f0210110          BIC      r1,r1,#0x10
000082  6139              STR      r1,[r7,#0x10]
                  |L13.132|
;;;620            }
;;;621        } 
;;;622        /* Return the FMC state */
;;;623        return temp_state;
;;;624    }
000084  e8bd81f0          POP      {r4-r8,pc}
;;;625    
                          ENDP

                  |L13.136|
                          DCD      0x45670123
                  |L13.140|
                          DCD      0x40022000
                  |L13.144|
                          DCD      0xcdef89ab
                  |L13.148|
                          DCD      0x1ffff808

                          AREA ||i.FMC_OB_Erase||, CODE, READONLY, ALIGN=2

                  FMC_OB_Erase PROC
;;;506      */
;;;507    FMC_State FMC_OB_Erase(void)
000000  b570              PUSH     {r4-r6,lr}
;;;508    {
;;;509        uint16_t temp_rdp = RDP_Level_0;
;;;510    
;;;511        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000002  f44f2670          MOV      r6,#0xf0000
000006  24a5              MOVS     r4,#0xa5              ;509
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FMC_WaitReady
00000e  4602              MOV      r2,r0
;;;512    
;;;513        /* Check the ReadOut Protection Option Byte */
;;;514        if(FMC_OB_GetRDP() != RESET)
000010  f7fffffe          BL       FMC_OB_GetRDP
000014  b100              CBZ      r0,|L14.24|
;;;515        {
;;;516            temp_rdp = 0x00;  
000016  2400              MOVS     r4,#0
                  |L14.24|
;;;517        }
;;;518    
;;;519        if(temp_state == FMC_READY)
000018  b99a              CBNZ     r2,|L14.66|
;;;520        {   
;;;521            /* Start erase the option byte */
;;;522            FMC->CMR |= FMC_CMR_OBER;
00001a  4d15              LDR      r5,|L14.112|
00001c  6928              LDR      r0,[r5,#0x10]
00001e  f0400020          ORR      r0,r0,#0x20
000022  6128              STR      r0,[r5,#0x10]
;;;523            FMC->CMR |= FMC_CMR_START;
000024  6928              LDR      r0,[r5,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6128              STR      r0,[r5,#0x10]
;;;524    
;;;525            /* Wait for the FMC ready */
;;;526            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       FMC_WaitReady
000032  0002              MOVS     r2,r0
;;;527        
;;;528            if(temp_state == FMC_READY)
000034  d007              BEQ      |L14.70|
;;;529            {
;;;530                /* Reset the OPER bit */
;;;531                FMC->CMR &= ~FMC_CMR_OBER;
;;;532           
;;;533                /* Set the OBPG bit */
;;;534                FMC->CMR |= FMC_CMR_OBPG;
;;;535    
;;;536                /* Set default RDP level */
;;;537                OB->RDP = (uint16_t)temp_rdp; 
;;;538    
;;;539                /* Wait for the FMC ready */
;;;540                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
;;;541     
;;;542                if(temp_state != FMC_TIMEOUT_ERR)
;;;543                {
;;;544                    /* Reset the OBPG bit */
;;;545                    FMC->CSR &= ~FMC_CMR_OBPG;
;;;546                }
;;;547            }
;;;548            else
;;;549            {
;;;550                if (temp_state != FMC_TIMEOUT_ERR)
000036  2a04              CMP      r2,#4
000038  d003              BEQ      |L14.66|
;;;551                {
;;;552                    /* Reset the OBPG bit */
;;;553                    FMC->CMR &= ~FMC_CMR_OBPG;
00003a  6928              LDR      r0,[r5,#0x10]
00003c  f0200010          BIC      r0,r0,#0x10
000040  6128              STR      r0,[r5,#0x10]
                  |L14.66|
;;;554                }
;;;555            }  
;;;556        }
;;;557        /* Return the FMC state */
;;;558        return temp_state;
000042  4610              MOV      r0,r2
;;;559    }
000044  bd70              POP      {r4-r6,pc}
                  |L14.70|
000046  6928              LDR      r0,[r5,#0x10]         ;531
000048  f0200020          BIC      r0,r0,#0x20           ;531
00004c  6128              STR      r0,[r5,#0x10]         ;531
00004e  6928              LDR      r0,[r5,#0x10]         ;534
000050  f0400010          ORR      r0,r0,#0x10           ;534
000054  6128              STR      r0,[r5,#0x10]         ;534
000056  4807              LDR      r0,|L14.116|
000058  8004              STRH     r4,[r0,#0]            ;537
00005a  4630              MOV      r0,r6                 ;540
00005c  f7fffffe          BL       FMC_WaitReady
000060  4602              MOV      r2,r0                 ;540
000062  2804              CMP      r0,#4                 ;542
000064  d0ed              BEQ      |L14.66|
000066  68e8              LDR      r0,[r5,#0xc]          ;545
000068  f0200010          BIC      r0,r0,#0x10           ;545
00006c  60e8              STR      r0,[r5,#0xc]          ;545
00006e  e7e8              B        |L14.66|
;;;560    
                          ENDP

                  |L14.112|
                          DCD      0x40022000
                  |L14.116|
                          DCD      0x1ffff800

                          AREA ||i.FMC_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FMC_OB_GetRDP PROC
;;;900      */
;;;901    TypeState FMC_OB_GetRDP(void)
000000  4903              LDR      r1,|L15.16|
;;;902    {
;;;903        TypeState RDPState = RESET;
000002  2000              MOVS     r0,#0
;;;904      
;;;905        if ((uint8_t)(FMC->OPTR & ( FMC_OPTR_PLEVEL1 )) != RESET)
000004  69c9              LDR      r1,[r1,#0x1c]
000006  0789              LSLS     r1,r1,#30
000008  d500              BPL      |L15.12|
;;;906        {
;;;907            RDPState = SET;
00000a  2001              MOVS     r0,#1
                  |L15.12|
;;;908        }
;;;909        else
;;;910        {
;;;911            RDPState = RESET;
;;;912        }
;;;913        return RDPState;
;;;914    }
00000c  4770              BX       lr
;;;915    
                          ENDP

00000e  0000              DCW      0x0000
                  |L15.16|
                          DCD      0x40022000

                          AREA ||i.FMC_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FMC_OB_GetUser PROC
;;;880      */
;;;881    uint8_t FMC_OB_GetUser(void)
000000  4802              LDR      r0,|L16.12|
;;;882    {
;;;883        return (uint8_t)(FMC->OPTR >> 8);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  f3c02007          UBFX     r0,r0,#8,#8
;;;884    }
000008  4770              BX       lr
;;;885    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40022000

                          AREA ||i.FMC_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FMC_OB_GetWRP PROC
;;;890      */
;;;891    uint32_t FMC_OB_GetWRP(void)
000000  4801              LDR      r0,|L17.8|
;;;892    {
;;;893        return (uint32_t)(FMC->WPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;894    }
000004  4770              BX       lr
;;;895    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x40022000

                          AREA ||i.FMC_OB_Lock||, CODE, READONLY, ALIGN=2

                  FMC_OB_Lock PROC
;;;484      */
;;;485    void FMC_OB_Lock(void)
000000  4802              LDR      r0,|L18.12|
;;;486    {
;;;487        /* Reset the OBWE bit */
;;;488        FMC->CMR &= ~FMC_CMR_OBWE;
000002  6901              LDR      r1,[r0,#0x10]
000004  f4217100          BIC      r1,r1,#0x200
000008  6101              STR      r1,[r0,#0x10]
;;;489    }
00000a  4770              BX       lr
;;;490    
                          ENDP

                  |L18.12|
                          DCD      0x40022000

                          AREA ||i.FMC_OB_RDPConfig||, CODE, READONLY, ALIGN=2

                  FMC_OB_RDPConfig PROC
;;;690      */
;;;691    FMC_State FMC_OB_RDPConfig(uint8_t OB_RDP)
000000  b570              PUSH     {r4-r6,lr}
;;;692    {
000002  4605              MOV      r5,r0
;;;693        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000004  f44f2670          MOV      r6,#0xf0000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FMC_WaitReady
;;;694    
;;;695        if(temp_state == FMC_READY)
00000e  2800              CMP      r0,#0
000010  d112              BNE      |L19.56|
;;;696        {
;;;697            FMC->CMR |= FMC_CMR_OBER;
000012  4c13              LDR      r4,|L19.96|
000014  6920              LDR      r0,[r4,#0x10]
000016  f0400020          ORR      r0,r0,#0x20
00001a  6120              STR      r0,[r4,#0x10]
;;;698            FMC->CMR |= FMC_CMR_START;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400040          ORR      r0,r0,#0x40
000022  6120              STR      r0,[r4,#0x10]
;;;699        
;;;700            /* Wait for the FMC ready */
;;;701            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       FMC_WaitReady
;;;702        
;;;703            if(temp_state == FMC_READY)
00002a  b130              CBZ      r0,|L19.58|
;;;704            {
;;;705                /* Reset the OBER bit */
;;;706                FMC->CMR &= ~FMC_CMR_OBER;
;;;707          
;;;708                /* Start the Option Bytes Programming */
;;;709                FMC->CMR |= FMC_CMR_OBPG;
;;;710           
;;;711                OB->RDP = OB_RDP;
;;;712    
;;;713                /* Wait for the FMC ready */
;;;714                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT); 
;;;715        
;;;716                if(temp_state != FMC_TIMEOUT_ERR)
;;;717                {
;;;718                    /* Reset the OBPG bit */
;;;719                    FMC->CMR &= ~FMC_CMR_OBPG;
;;;720                }
;;;721            }
;;;722            else
;;;723            {
;;;724                if(temp_state != FMC_TIMEOUT_ERR)
00002c  2804              CMP      r0,#4
00002e  d003              BEQ      |L19.56|
;;;725                {
;;;726                    /* Reset the OBER Bit */
;;;727                    FMC->CMR &= ~FMC_CMR_OBER;
000030  6921              LDR      r1,[r4,#0x10]
000032  f0210120          BIC      r1,r1,#0x20
                  |L19.54|
000036  6121              STR      r1,[r4,#0x10]         ;719
                  |L19.56|
;;;728                }
;;;729            }
;;;730        }  
;;;731        /* Return the FMC state */
;;;732        return temp_state;
;;;733    }
000038  bd70              POP      {r4-r6,pc}
                  |L19.58|
00003a  6920              LDR      r0,[r4,#0x10]         ;706
00003c  f0200020          BIC      r0,r0,#0x20           ;706
000040  6120              STR      r0,[r4,#0x10]         ;706
000042  6920              LDR      r0,[r4,#0x10]         ;709
000044  f0400010          ORR      r0,r0,#0x10           ;709
000048  6120              STR      r0,[r4,#0x10]         ;709
00004a  4806              LDR      r0,|L19.100|
00004c  8005              STRH     r5,[r0,#0]            ;711
00004e  4630              MOV      r0,r6                 ;714
000050  f7fffffe          BL       FMC_WaitReady
000054  2804              CMP      r0,#4                 ;716
000056  d0ef              BEQ      |L19.56|
000058  6921              LDR      r1,[r4,#0x10]         ;719
00005a  f0210110          BIC      r1,r1,#0x10           ;719
00005e  e7ea              B        |L19.54|
;;;734    
                          ENDP

                  |L19.96|
                          DCD      0x40022000
                  |L19.100|
                          DCD      0x1ffff800

                          AREA ||i.FMC_OB_Reset||, CODE, READONLY, ALIGN=2

                  FMC_OB_Reset PROC
;;;495      */
;;;496    void FMC_OB_Reset(void)
000000  4802              LDR      r0,|L20.12|
;;;497    {
;;;498        /* Set the OPTR bit */
;;;499        FMC->CMR |= FMC_CMR_OPTR;		
000002  6901              LDR      r1,[r0,#0x10]
000004  f4415100          ORR      r1,r1,#0x2000
000008  6101              STR      r1,[r0,#0x10]
;;;500    }
00000a  4770              BX       lr
;;;501    
                          ENDP

                  |L20.12|
                          DCD      0x40022000

                          AREA ||i.FMC_OB_Unlock||, CODE, READONLY, ALIGN=2

                  FMC_OB_Unlock PROC
;;;469      */
;;;470    void FMC_OB_Unlock(void)
000000  4804              LDR      r0,|L21.20|
;;;471    {
;;;472        if((FMC->CMR & FMC_CMR_OBWE) == RESET)
000002  6901              LDR      r1,[r0,#0x10]
000004  0589              LSLS     r1,r1,#22
000006  d403              BMI      |L21.16|
;;;473        { 
;;;474            /* Write the FMC key */
;;;475            FMC->OBKEYR = FMC_KEY1;
000008  4903              LDR      r1,|L21.24|
00000a  6081              STR      r1,[r0,#8]
;;;476            FMC->OBKEYR = FMC_KEY2;
00000c  4903              LDR      r1,|L21.28|
00000e  6081              STR      r1,[r0,#8]
                  |L21.16|
;;;477        }
;;;478    }
000010  4770              BX       lr
;;;479    
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      0x40022000
                  |L21.24|
                          DCD      0x45670123
                  |L21.28|
                          DCD      0xcdef89ab

                          AREA ||i.FMC_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FMC_OB_UserConfig PROC
;;;747      */
;;;748    FMC_State  FMC_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_DEEPSLEEP, uint8_t OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;749    {
000004  4605              MOV      r5,r0
;;;750        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000006  f44f2870          MOV      r8,#0xf0000
00000a  4616              MOV      r6,r2                 ;749
00000c  460f              MOV      r7,r1                 ;749
00000e  4640              MOV      r0,r8
000010  f7fffffe          BL       FMC_WaitReady
;;;751      
;;;752        if(temp_state == FMC_READY)
000014  2800              CMP      r0,#0
000016  d113              BNE      |L22.64|
;;;753        {
;;;754            /* Set the OBPG bit*/
;;;755            FMC->CMR |= FMC_CMR_OBPG; 
000018  4c0a              LDR      r4,|L22.68|
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400010          ORR      r0,r0,#0x10
000020  6120              STR      r0,[r4,#0x10]
;;;756    
;;;757            OB->USER = (uint16_t)((uint16_t)(OB_IWDG | OB_DEEPSLEEP) | (uint16_t)(OB_STDBY | 0xF8));
000022  433d              ORRS     r5,r5,r7
000024  4808              LDR      r0,|L22.72|
000026  4335              ORRS     r5,r5,r6
000028  f04501f8          ORR      r1,r5,#0xf8
00002c  8001              STRH     r1,[r0,#0]
;;;758        
;;;759            /* Wait for the FMC ready */
;;;760            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       FMC_WaitReady
;;;761    
;;;762            if(temp_state != FMC_TIMEOUT_ERR)
000034  2804              CMP      r0,#4
000036  d003              BEQ      |L22.64|
;;;763            {
;;;764                /* Reset the OBPG bit */
;;;765                FMC->CMR &= ~FMC_CMR_OBPG;
000038  6921              LDR      r1,[r4,#0x10]
00003a  f0210110          BIC      r1,r1,#0x10
00003e  6121              STR      r1,[r4,#0x10]
                  |L22.64|
;;;766            }
;;;767        }
;;;768        /* Return the FMC state */
;;;769        return temp_state;
;;;770    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;771    
                          ENDP

                  |L22.68|
                          DCD      0x40022000
                  |L22.72|
                          DCD      0x1ffff802

                          AREA ||i.FMC_OB_WriteUser||, CODE, READONLY, ALIGN=2

                  FMC_OB_WriteUser PROC
;;;821      */
;;;822    FMC_State FMC_OB_WriteUser(uint8_t OB_USER)
000000  b570              PUSH     {r4-r6,lr}
;;;823    {
000002  4605              MOV      r5,r0
;;;824        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000004  f44f2670          MOV      r6,#0xf0000
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FMC_WaitReady
;;;825      
;;;826        if(temp_state == FMC_READY)
00000e  2800              CMP      r0,#0
000010  d111              BNE      |L23.54|
;;;827        {
;;;828            /* Set the OBPG bit */
;;;829            FMC->CMR |= FMC_CMR_OBPG; 
000012  4c09              LDR      r4,|L23.56|
000014  6920              LDR      r0,[r4,#0x10]
000016  f0400010          ORR      r0,r0,#0x10
00001a  6120              STR      r0,[r4,#0x10]
;;;830    
;;;831            OB->USER = OB_USER | 0xf0;
00001c  4807              LDR      r0,|L23.60|
00001e  f04501f0          ORR      r1,r5,#0xf0
000022  8001              STRH     r1,[r0,#0]
;;;832      
;;;833            /* Wait for the FMC ready */
;;;834            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       FMC_WaitReady
;;;835    
;;;836            if(temp_state != FMC_TIMEOUT_ERR)
00002a  2804              CMP      r0,#4
00002c  d003              BEQ      |L23.54|
;;;837            {
;;;838                /* Reset the OBPG bit */
;;;839                FMC->CMR &= ~FMC_CMR_OBPG;
00002e  6921              LDR      r1,[r4,#0x10]
000030  f0210110          BIC      r1,r1,#0x10
000034  6121              STR      r1,[r4,#0x10]
                  |L23.54|
;;;840            }
;;;841        }    
;;;842        /* Return the FMC state */
;;;843        return temp_state;
;;;844    }
000036  bd70              POP      {r4-r6,pc}
;;;845    
                          ENDP

                  |L23.56|
                          DCD      0x40022000
                  |L23.60|
                          DCD      0x1ffff802

                          AREA ||i.FMC_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FMC_ProgramOptionByteData PROC
;;;852      */
;;;853    FMC_State FMC_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;854    {
000002  4606              MOV      r6,r0
;;;855        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000004  f44f2770          MOV      r7,#0xf0000
000008  460d              MOV      r5,r1                 ;854
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FMC_WaitReady
;;;856    
;;;857        if(temp_state == FMC_READY)
000010  2800              CMP      r0,#0
000012  d10e              BNE      |L24.50|
;;;858        {
;;;859            /* SET the OPTPG bit */
;;;860            FMC->CMR |= FMC_CMR_OBPG; 
000014  4c07              LDR      r4,|L24.52|
000016  6920              LDR      r0,[r4,#0x10]
000018  f0400010          ORR      r0,r0,#0x10
00001c  6120              STR      r0,[r4,#0x10]
;;;861            *(__IO uint16_t*)Address = Data;
00001e  8035              STRH     r5,[r6,#0]
;;;862        
;;;863            /* Wait for the FMC ready */
;;;864            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       FMC_WaitReady
;;;865        
;;;866            if(temp_state != FMC_TIMEOUT_ERR)
000026  2804              CMP      r0,#4
000028  d003              BEQ      |L24.50|
;;;867            {
;;;868                /* Reset the OPTPG bit */
;;;869                FMC->CMR &= ~FMC_CMR_OBPG;
00002a  6921              LDR      r1,[r4,#0x10]
00002c  f0210110          BIC      r1,r1,#0x10
000030  6121              STR      r1,[r4,#0x10]
                  |L24.50|
;;;870            }
;;;871        }
;;;872        /* Return the FMC state */
;;;873        return temp_state;
;;;874    }
000032  bdf0              POP      {r4-r7,pc}
;;;875    
                          ENDP

                  |L24.52|
                          DCD      0x40022000

                          AREA ||i.FMC_ProgramWord||, CODE, READONLY, ALIGN=2

                  FMC_ProgramWord PROC
;;;346      */
;;;347    FMC_State FMC_ProgramWord(uint32_t Address, uint32_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;348    {
000002  4606              MOV      r6,r0
;;;349    #if defined GD32F10X_XD || defined GD32F10X_CL
;;;350        FMC_State temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);	 
;;;351        if(Address < FMC_B1_END_ADDRESS)
;;;352        { 
;;;353            FMC_State temp_state = FMC_B1_WaitReady(FMC_TIMEOUT_COUNT);	 
;;;354      
;;;355            if(temp_state == FMC_READY)
;;;356            {
;;;357                /* Set the PG bit to start program */
;;;358                FMC->CMR |= FMC_CMR_PG;
;;;359      
;;;360                *(__IO uint32_t*)Address = Data;	
;;;361    
;;;362                /* Wait for the FMC ready */
;;;363                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
;;;364        
;;;365                /* Reset the PG bit */
;;;366                FMC->CMR &= ~FMC_CMR_PG;
;;;367            } 
;;;368        }
;;;369        else
;;;370        {
;;;371            FMC_State temp_state = FMC_B2_WaitReady(FMC_TIMEOUT_COUNT);	  
;;;372      
;;;373            if(temp_state == FMC_READY)
;;;374            {
;;;375                /* Set the PG bit to start program */
;;;376                FMC->CMR2 |= FMC_CMR_PG;
;;;377      
;;;378                *(__IO uint32_t*)Address = Data;	
;;;379    
;;;380                /* Wait for the FMC ready */
;;;381                temp_state = FMC_B2_WaitReady(FMC_TIMEOUT_COUNT);
;;;382        
;;;383                /* Reset the PG bit */
;;;384                FMC->CMR2 &= ~FMC_CMR_PG;
;;;385            }
;;;386        }
;;;387    
;;;388    
;;;389    #else
;;;390        FMC_State temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);	 
000004  f44f2770          MOV      r7,#0xf0000
000008  460d              MOV      r5,r1                 ;348
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FMC_WaitReady
;;;391      
;;;392        if(temp_state == FMC_READY)
000010  2800              CMP      r0,#0
000012  d10c              BNE      |L25.46|
;;;393        {
;;;394            /* Set the PG bit to start program */
;;;395            FMC->CMR |= FMC_CMR_PG;
000014  4c06              LDR      r4,|L25.48|
000016  6920              LDR      r0,[r4,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  6120              STR      r0,[r4,#0x10]
;;;396      
;;;397            *(__IO uint32_t*)Address = Data;
00001e  6035              STR      r5,[r6,#0]
;;;398    
;;;399            /* Wait for the FMC ready */
;;;400            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       FMC_WaitReady
;;;401        
;;;402            /* Reset the PG bit */
;;;403            FMC->CMR &= ~FMC_CMR_PG;
000026  6921              LDR      r1,[r4,#0x10]
000028  f0210101          BIC      r1,r1,#1
00002c  6121              STR      r1,[r4,#0x10]
                  |L25.46|
;;;404        } 
;;;405    #endif
;;;406        /* Return the FMC state */
;;;407        return temp_state;
;;;408    }
00002e  bdf0              POP      {r4-r7,pc}
;;;409    
                          ENDP

                  |L25.48|
                          DCD      0x40022000

                          AREA ||i.FMC_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FMC_ReadOutProtection PROC
;;;630      */
;;;631    FMC_State FMC_ReadOutProtection(TypeState NewValue)
000000  b570              PUSH     {r4-r6,lr}
;;;632    {
000002  4606              MOV      r6,r0
;;;633        FMC_State temp_state = FMC_READY;
;;;634        /* Wait for the FMC ready */
;;;635        temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000004  f44f2570          MOV      r5,#0xf0000
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       FMC_WaitReady
;;;636        if(temp_state == FMC_READY)
00000e  2800              CMP      r0,#0
000010  d119              BNE      |L26.70|
;;;637        {
;;;638            /* Unlock option bytes */
;;;639            FMC->OBKEYR = FMC_KEY1;
000012  4c1a              LDR      r4,|L26.124|
000014  4818              LDR      r0,|L26.120|
000016  60a0              STR      r0,[r4,#8]
;;;640            FMC->OBKEYR = FMC_KEY2;
000018  4819              LDR      r0,|L26.128|
00001a  60a0              STR      r0,[r4,#8]
                  |L26.28|
;;;641            while((FMC->CMR&FMC_CMR_OBWE)!=FMC_CMR_OBWE )
00001c  6920              LDR      r0,[r4,#0x10]
00001e  0580              LSLS     r0,r0,#22
000020  d5fc              BPL      |L26.28|
;;;642            {}
;;;643            FMC->CMR |= FMC_CMR_OBER;
000022  6920              LDR      r0,[r4,#0x10]
000024  f0400020          ORR      r0,r0,#0x20
000028  6120              STR      r0,[r4,#0x10]
;;;644            FMC->CMR |= FMC_CMR_START;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6120              STR      r0,[r4,#0x10]
;;;645            /* Wait for the FMC ready */
;;;646            temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       FMC_WaitReady
;;;647            if(temp_state == FMC_READY)
000038  b130              CBZ      r0,|L26.72|
;;;648            {
;;;649                /* Disable the OBER Bit */
;;;650                FMC->CMR &=~FMC_CMR_OBER ;
;;;651                /* Enable the OBPG Bit */
;;;652                FMC->CMR |= FMC_CMR_OBPG; 
;;;653                if(NewValue != DISABLE)
;;;654                {
;;;655                    OB->RDP = 0x00;
;;;656                }
;;;657                else
;;;658                {
;;;659                    OB->RDP = RDP_Level_0;  
;;;660                }
;;;661                /* Wait for the FMC ready */
;;;662                temp_state = FMC_WaitReady(FMC_TIMEOUT_COUNT);
;;;663        
;;;664                if(temp_state != FMC_TIMEOUT_ERR)
;;;665                {
;;;666                    /* Enable the OBPG Bit */
;;;667                    FMC->CMR &=~FMC_CMR_OBPG ;
;;;668                }
;;;669            }
;;;670            else 
;;;671            {
;;;672                if(temp_state != FMC_TIMEOUT_ERR)
00003a  2804              CMP      r0,#4
00003c  d003              BEQ      |L26.70|
;;;673                {
;;;674                    /* Disable the OBER Bit */
;;;675                    FMC->CMR &=~FMC_CMR_OBER ;
00003e  6921              LDR      r1,[r4,#0x10]
000040  f0210120          BIC      r1,r1,#0x20
                  |L26.68|
000044  6121              STR      r1,[r4,#0x10]         ;667
                  |L26.70|
;;;676                }
;;;677            }
;;;678        }
;;;679        /* Return the FMC state */
;;;680        return temp_state;       
;;;681    }
000046  bd70              POP      {r4-r6,pc}
                  |L26.72|
000048  6920              LDR      r0,[r4,#0x10]         ;650
00004a  f0200020          BIC      r0,r0,#0x20           ;650
00004e  6120              STR      r0,[r4,#0x10]         ;650
000050  6920              LDR      r0,[r4,#0x10]         ;652
000052  f0400010          ORR      r0,r0,#0x10           ;652
000056  6120              STR      r0,[r4,#0x10]         ;652
000058  480a              LDR      r0,|L26.132|
00005a  b10e              CBZ      r6,|L26.96|
00005c  2100              MOVS     r1,#0                 ;655
00005e  e000              B        |L26.98|
                  |L26.96|
000060  21a5              MOVS     r1,#0xa5              ;659
                  |L26.98|
000062  8001              STRH     r1,[r0,#0]            ;659
000064  4628              MOV      r0,r5                 ;662
000066  f7fffffe          BL       FMC_WaitReady
00006a  2804              CMP      r0,#4                 ;664
00006c  d0eb              BEQ      |L26.70|
00006e  6921              LDR      r1,[r4,#0x10]         ;667
000070  f0210110          BIC      r1,r1,#0x10           ;667
000074  e7e6              B        |L26.68|
;;;682    
                          ENDP

000076  0000              DCW      0x0000
                  |L26.120|
                          DCD      0x45670123
                  |L26.124|
                          DCD      0x40022000
                  |L26.128|
                          DCD      0xcdef89ab
                  |L26.132|
                          DCD      0x1ffff800

                          AREA ||i.FMC_Unlock||, CODE, READONLY, ALIGN=2

                  FMC_Unlock PROC
;;;63       */
;;;64     void FMC_Unlock(void)
000000  4804              LDR      r0,|L27.20|
;;;65     {
;;;66         if((FMC->CMR & FMC_CMR_LK) != RESET)
000002  6901              LDR      r1,[r0,#0x10]
000004  0609              LSLS     r1,r1,#24
000006  d503              BPL      |L27.16|
;;;67         {
;;;68             /* Write the FMC key */
;;;69             FMC->UKEYR = FMC_KEY1;
000008  4903              LDR      r1,|L27.24|
00000a  6041              STR      r1,[r0,#4]
;;;70             FMC->UKEYR = FMC_KEY2;
00000c  4903              LDR      r1,|L27.28|
00000e  6041              STR      r1,[r0,#4]
                  |L27.16|
;;;71         }
;;;72     #if defined GD32F10X_XD || defined GD32F10X_CL
;;;73         /* Authorize the FPEC of Bank2 Access */
;;;74         if((FMC->CMR2 & FMC_CMR_LK) != RESET)
;;;75         {
;;;76             FMC->UKEYR2 = FMC_KEY1;
;;;77             FMC->UKEYR2 = FMC_KEY2;
;;;78         }
;;;79     #endif /* GD32F10X_XD||GD32F10X_CL */
;;;80     }
000010  4770              BX       lr
;;;81     
                          ENDP

000012  0000              DCW      0x0000
                  |L27.20|
                          DCD      0x40022000
                  |L27.24|
                          DCD      0x45670123
                  |L27.28|
                          DCD      0xcdef89ab

                          AREA ||i.FMC_UnlockB1||, CODE, READONLY, ALIGN=2

                  FMC_UnlockB1 PROC
;;;90       */
;;;91     void FMC_UnlockB1(void)
000000  4804              LDR      r0,|L28.20|
;;;92     {
;;;93         /* Authorize the FPEC of Bank1 Access */
;;;94         if((FMC->CMR & FMC_CMR_LK) != RESET)
000002  6901              LDR      r1,[r0,#0x10]
000004  0609              LSLS     r1,r1,#24
000006  d503              BPL      |L28.16|
;;;95         {
;;;96             FMC->UKEYR = FMC_KEY1;
000008  4903              LDR      r1,|L28.24|
00000a  6041              STR      r1,[r0,#4]
;;;97             FMC->UKEYR = FMC_KEY2;
00000c  4903              LDR      r1,|L28.28|
00000e  6041              STR      r1,[r0,#4]
                  |L28.16|
;;;98         }
;;;99     }
000010  4770              BX       lr
;;;100    
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      0x40022000
                  |L28.24|
                          DCD      0x45670123
                  |L28.28|
                          DCD      0xcdef89ab

                          AREA ||i.FMC_WaitReady||, CODE, READONLY, ALIGN=1

                  FMC_WaitReady PROC
;;;1206     */
;;;1207   FMC_State FMC_WaitReady(uint32_t uCount)
000000  b500              PUSH     {lr}
;;;1208   { 
000002  4603              MOV      r3,r0
                  |L29.4|
;;;1209       FMC_State temp_state = FMC_BSY;
;;;1210     
;;;1211       /* Wait for FMC ready */
;;;1212       do
;;;1213       {
;;;1214           /* Get FMC state */
;;;1215           temp_state = FMC_GetState();
000004  f7fffffe          BL       FMC_GetState
000008  1e5b              SUBS     r3,r3,#1
;;;1216           uCount--;
;;;1217       }while((temp_state == FMC_BSY) && (uCount != 0x00));
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L29.20|
00000e  2b00              CMP      r3,#0
000010  d1f8              BNE      |L29.4|
;;;1218     
;;;1219       if(temp_state == FMC_BSY)
;;;1220       {
;;;1221           temp_state = FMC_TIMEOUT_ERR;
000012  2004              MOVS     r0,#4
                  |L29.20|
;;;1222       }
;;;1223       /* Return the FMC state */
;;;1224       return temp_state;
;;;1225   }
000014  bd00              POP      {pc}
;;;1226   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\GIGA32\\gd32\\peripherals\\src\\gd32f10X_fmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10X_fmc_c_f1f6b3eb____REV16|
#line 129 "..\\..\\cmsis-core\\core_cmInstr.h"
|__asm___14_gd32f10X_fmc_c_f1f6b3eb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10X_fmc_c_f1f6b3eb____REVSH|
#line 144
|__asm___14_gd32f10X_fmc_c_f1f6b3eb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
