; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\gd32f10x_gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gd32f10x_gpio.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\startup -I..\..\cmsis-core -I..\src -I..\..\GIGA32\inc -I..\..\GIGA32\src -I..\..\GIGA32\gd32\peripherals\inc -I..\..\GIGA32\gd32\peripherals\src -I.\RTE\_Target_1 -IF:\software\mdk\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\software\mdk\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD -DDAPLINK_VERSION=242 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DINTERFACE_GD32F103 -DCPU_GD32F103CBT6 -DDAPLINK_HIC_ID=0x97969905 -DBL_TARGET_FLASH -DUSE_STDPERIPH_DRIVER -DGD32F10X_MD -DUSE_HSE_16MHZ --omf_browse=.\objects\gd32f10x_gpio.crf ..\..\GIGA32\gd32\peripherals\src\gd32f10x_gpio.c]
                          THUMB

                          AREA ||i.GPIO_AFDeInit||, CODE, READONLY, ALIGN=1

                  GPIO_AFDeInit PROC
;;;115      */
;;;116    void GPIO_AFDeInit(void)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118        /* Enable AFIO reset state */
;;;119        RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_AF, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;120        /* Release AFIO from reset state */
;;;121        RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_AF, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2001              MOVS     r0,#1
000012  f7ffbffe          B.W      RCC_APB2PeriphReset_Enable
;;;122    }
;;;123    
                          ENDP


                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;56       */     
;;;57     void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  4925              LDR      r1,|L2.152|
;;;58     {
000002  b510              PUSH     {r4,lr}
;;;59         if (GPIOx == GPIOA)
000004  4288              CMP      r0,r1
000006  d106              BNE      |L2.22|
;;;60         {
;;;61             /* Enable GPIOA reset state */
;;;62             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOA, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;63             /* Release GPIOA from reset state */
;;;64             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOA, DISABLE);
000010  2100              MOVS     r1,#0
000012  2004              MOVS     r0,#4
000014  e03b              B        |L2.142|
                  |L2.22|
;;;65         }
;;;66         else if (GPIOx == GPIOB)
000016  4921              LDR      r1,|L2.156|
000018  4288              CMP      r0,r1
00001a  d106              BNE      |L2.42|
;;;67         {
;;;68             /* Enable GPIOB reset state */
;;;69             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOB, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;70             /* Release GPIOB from reset state */
;;;71             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOB, DISABLE);
000024  2100              MOVS     r1,#0
000026  2008              MOVS     r0,#8
000028  e031              B        |L2.142|
                  |L2.42|
;;;72         }
;;;73         else if (GPIOx == GPIOC)
00002a  491d              LDR      r1,|L2.160|
00002c  4288              CMP      r0,r1
00002e  d106              BNE      |L2.62|
;;;74         {
;;;75             /* Enable GPIOC reset state */
;;;76             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOC, ENABLE);
000030  2101              MOVS     r1,#1
000032  2010              MOVS     r0,#0x10
000034  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;77             /* Release GPIOC from reset state */
;;;78             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOC, DISABLE);
000038  2100              MOVS     r1,#0
00003a  2010              MOVS     r0,#0x10
00003c  e027              B        |L2.142|
                  |L2.62|
;;;79         }
;;;80         else if (GPIOx == GPIOD)
00003e  4919              LDR      r1,|L2.164|
000040  4288              CMP      r0,r1
000042  d106              BNE      |L2.82|
;;;81         {
;;;82             /* Enable GPIOD reset state */
;;;83             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOD, ENABLE);
000044  2101              MOVS     r1,#1
000046  2020              MOVS     r0,#0x20
000048  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;84             /* Release GPIOD from reset state */
;;;85             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOD, DISABLE);
00004c  2100              MOVS     r1,#0
00004e  2020              MOVS     r0,#0x20
000050  e01d              B        |L2.142|
                  |L2.82|
;;;86         }
;;;87         else if (GPIOx == GPIOE)
000052  4915              LDR      r1,|L2.168|
000054  4288              CMP      r0,r1
000056  d106              BNE      |L2.102|
;;;88         {
;;;89             /* Enable GPIOE reset state */
;;;90             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOE, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2040              MOVS     r0,#0x40
00005c  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;91             /* Release GPIOE from reset state */
;;;92             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOE, DISABLE);
000060  2100              MOVS     r1,#0
000062  2040              MOVS     r0,#0x40
000064  e013              B        |L2.142|
                  |L2.102|
;;;93         }
;;;94         else if (GPIOx == GPIOF)
000066  4911              LDR      r1,|L2.172|
000068  4288              CMP      r0,r1
00006a  d106              BNE      |L2.122|
;;;95         {
;;;96             /* Enable GPIOF reset state */
;;;97             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOF, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2080              MOVS     r0,#0x80
000070  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;98             /* Release GPIOF from reset state */
;;;99             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOF, DISABLE);
000074  2100              MOVS     r1,#0
000076  2080              MOVS     r0,#0x80
000078  e009              B        |L2.142|
                  |L2.122|
;;;100        }
;;;101        else if(GPIOx == GPIOG)
00007a  490d              LDR      r1,|L2.176|
00007c  4288              CMP      r0,r1
00007e  d10a              BNE      |L2.150|
;;;102        {
;;;103            /* Enable GPIOG reset state */
;;;104            RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOG, ENABLE);
000080  1584              ASRS     r4,r0,#22
000082  2101              MOVS     r1,#1
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;105            /* Release GPIOG from reset state */
;;;106            RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_GPIOG, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  4620              MOV      r0,r4
                  |L2.142|
00008e  e8bd4010          POP      {r4,lr}
000092  f7ffbffe          B.W      RCC_APB2PeriphReset_Enable
                  |L2.150|
;;;107        }
;;;108    }
000096  bd10              POP      {r4,pc}
;;;109    
                          ENDP

                  |L2.152|
                          DCD      0x40010800
                  |L2.156|
                          DCD      0x40010c00
                  |L2.160|
                          DCD      0x40011000
                  |L2.164|
                          DCD      0x40011400
                  |L2.168|
                          DCD      0x40011800
                  |L2.172|
                          DCD      0x40011c00
                  |L2.176|
                          DCD      0x40012000

                          AREA ||i.GPIO_ETH_MediaInterfaceConfig||, CODE, READONLY, ALIGN=2

                  GPIO_ETH_MediaInterfaceConfig PROC
;;;546      */
;;;547    void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface)
000000  4a03              LDR      r2,|L3.16|
;;;548    {
;;;549        uint32_t temp = 0;
;;;550        temp = AFIO->AFIO_PCFR1;
000002  6851              LDR      r1,[r2,#4]
;;;551        /* Clear MII_RMII_SEL bit */
;;;552        temp &= ~((uint32_t)AFIO_PCFR1_MII_RMII);
000004  f4210100          BIC      r1,r1,#0x800000
;;;553        /* Configure MII_RMII bit according to GPIO_ETH_MediaInterface value */
;;;554        temp |= GPIO_ETH_MediaInterface;
000008  4301              ORRS     r1,r1,r0
;;;555        /* Store the new value */
;;;556        AFIO->AFIO_PCFR1 = temp;
00000a  6051              STR      r1,[r2,#4]
;;;557    }
00000c  4770              BX       lr
;;;558     
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40010000

                          AREA ||i.GPIO_EXTILineConfig||, CODE, READONLY, ALIGN=2

                  GPIO_EXTILineConfig PROC
;;;506      */
;;;507    void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
000000  078a              LSLS     r2,r1,#30
;;;508    {
;;;509        uint32_t temp = 0x00;
;;;510    
;;;511        temp = ((uint32_t)0x0f) << (AFIO_ESSR_PIN_FIELDS * (GPIO_PinSource & (uint8_t)0x03));
000002  0f13              LSRS     r3,r2,#28
000004  b510              PUSH     {r4,lr}               ;508
000006  220f              MOVS     r2,#0xf
000008  409a              LSLS     r2,r2,r3
;;;512        /* Select EXTI0->EXTI3 bit */
;;;513        if(GPIO_PinSource < AFIO_ESSR1_BITS_FIELDS)
;;;514        {
;;;515            AFIO->AFIO_ESSR1 &= ~temp;
00000a  4c12              LDR      r4,|L4.84|
;;;516            AFIO->AFIO_ESSR1 |= (((uint32_t)GPIO_PortSource) << (AFIO_ESSR_PIN_FIELDS * (GPIO_PinSource & (uint8_t)0x03)));  
00000c  4098              LSLS     r0,r0,r3
00000e  2904              CMP      r1,#4                 ;513
000010  d206              BCS      |L4.32|
000012  68a1              LDR      r1,[r4,#8]            ;515
000014  4391              BICS     r1,r1,r2              ;515
000016  60a1              STR      r1,[r4,#8]            ;515
000018  68a1              LDR      r1,[r4,#8]
00001a  4301              ORRS     r1,r1,r0
00001c  60a1              STR      r1,[r4,#8]
;;;517        }
;;;518        /* Select EXTI4->EXTI7 bit */
;;;519        else if(GPIO_PinSource < AFIO_ESSR2_BITS_FIELDS)
;;;520        {
;;;521            AFIO->AFIO_ESSR2 &= ~temp;
;;;522            AFIO->AFIO_ESSR2 |= (((uint32_t)GPIO_PortSource) << (AFIO_ESSR_PIN_FIELDS * (GPIO_PinSource & (uint8_t)0x03)));  
;;;523        }
;;;524        /* Select EXTI8->EXTI11 bit */
;;;525        else if(GPIO_PinSource < AFIO_ESSR3_BITS_FIELDS)
;;;526        {
;;;527            AFIO->AFIO_ESSR3 &= ~temp;
;;;528            AFIO->AFIO_ESSR3 |= (((uint32_t)GPIO_PortSource) << (AFIO_ESSR_PIN_FIELDS * (GPIO_PinSource & (uint8_t)0x03))); 
;;;529        }
;;;530        /* Select EXTI12->EXTI15 bit */
;;;531        else
;;;532        {
;;;533            AFIO->AFIO_ESSR4 &= ~temp;
;;;534            AFIO->AFIO_ESSR4 |= (((uint32_t)GPIO_PortSource) << (AFIO_ESSR_PIN_FIELDS * (GPIO_PinSource & (uint8_t)0x03))); 
;;;535        }
;;;536    }
00001e  bd10              POP      {r4,pc}
                  |L4.32|
000020  2908              CMP      r1,#8                 ;519
000022  d206              BCS      |L4.50|
000024  68e1              LDR      r1,[r4,#0xc]          ;521
000026  4391              BICS     r1,r1,r2              ;521
000028  60e1              STR      r1,[r4,#0xc]          ;521
00002a  68e1              LDR      r1,[r4,#0xc]          ;522
00002c  4301              ORRS     r1,r1,r0              ;522
00002e  60e1              STR      r1,[r4,#0xc]          ;522
000030  bd10              POP      {r4,pc}
                  |L4.50|
000032  290c              CMP      r1,#0xc               ;525
000034  d206              BCS      |L4.68|
000036  6921              LDR      r1,[r4,#0x10]         ;527
000038  4391              BICS     r1,r1,r2              ;527
00003a  6121              STR      r1,[r4,#0x10]         ;527
00003c  6921              LDR      r1,[r4,#0x10]         ;528
00003e  4301              ORRS     r1,r1,r0              ;528
000040  6121              STR      r1,[r4,#0x10]         ;528
000042  bd10              POP      {r4,pc}
                  |L4.68|
000044  6961              LDR      r1,[r4,#0x14]         ;533
000046  4391              BICS     r1,r1,r2              ;533
000048  6161              STR      r1,[r4,#0x14]         ;533
00004a  6961              LDR      r1,[r4,#0x14]         ;534
00004c  4301              ORRS     r1,r1,r0              ;534
00004e  6161              STR      r1,[r4,#0x14]         ;534
000050  bd10              POP      {r4,pc}
;;;537    
                          ENDP

000052  0000              DCW      0x0000
                  |L4.84|
                          DCD      0x40010000

                          AREA ||i.GPIO_EventOutputConfig||, CODE, READONLY, ALIGN=2

                  GPIO_EventOutputConfig PROC
;;;368      */
;;;369    void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
000000  4b05              LDR      r3,|L5.24|
;;;370    {
000002  b510              PUSH     {r4,lr}
;;;371        uint32_t temp = 0x00;
;;;372    
;;;373        temp = AFIO->AFIO_EVR;
000004  681a              LDR      r2,[r3,#0]
;;;374        /* Clear the PORT[6:4] and PIN[3:0] bits */
;;;375        temp &= ECR_PORTPINCONFIG_MASK;
000006  f64f7480          MOV      r4,#0xff80
00000a  4022              ANDS     r2,r2,r4
;;;376        temp |= (uint32_t)GPIO_PortSource << 0x04;
00000c  ea421000          ORR      r0,r2,r0,LSL #4
;;;377        temp |= GPIO_PinSource;
000010  4308              ORRS     r0,r0,r1
;;;378        AFIO->AFIO_EVR = temp;
000012  6018              STR      r0,[r3,#0]
;;;379    }
000014  bd10              POP      {r4,pc}
;;;380    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x40010000

                          AREA ||i.GPIO_EventOutput_Enable||, CODE, READONLY, ALIGN=2

                  GPIO_EventOutput_Enable PROC
;;;387      */
;;;388    void GPIO_EventOutput_Enable(uint32_t AFIO_Event, TypeState NewState)
000000  4805              LDR      r0,|L6.24|
;;;389    {
;;;390        /*  Enable or disable the Event Output */   
;;;391        if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;392        {
;;;393           AFIO->AFIO_EVR  |= AFIO_ECR_EVOE_SET;
;;;394        }
;;;395        else
;;;396        {
;;;397           AFIO->AFIO_EVR &= AFIO_ECR_EVOE_RESET;
000004  6801              LDR      r1,[r0,#0]
000006  d002              BEQ      |L6.14|
000008  f0410180          ORR      r1,r1,#0x80           ;393
00000c  e001              B        |L6.18|
                  |L6.14|
00000e  f0210180          BIC      r1,r1,#0x80
                  |L6.18|
000012  6001              STR      r1,[r0,#0]            ;393
;;;398        }
;;;399    }
000014  4770              BX       lr
;;;400    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40010000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;129      */
;;;130    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitPara* GPIO_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;131    {
;;;132        uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
;;;133        uint32_t tempreg = 0x00, pinmask = 0x00;
;;;134    
;;;135        /* GPIO Mode Configuration */
;;;136        currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
000002  78cc              LDRB     r4,[r1,#3]
000004  2200              MOVS     r2,#0                 ;132
000006  f004030f          AND      r3,r4,#0xf
;;;137        if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
00000a  06e4              LSLS     r4,r4,#27
00000c  d501              BPL      |L7.18|
;;;138        {
;;;139            /* Output mode */
;;;140            currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
00000e  788c              LDRB     r4,[r1,#2]
000010  4323              ORRS     r3,r3,r4
                  |L7.18|
;;;141        }
;;;142        /* GPIO CTLR1 Configuration */
;;;143        /* Configure the eight low port pins */
;;;144        if (((uint32_t)GPIO_InitStruct->GPIO_Pin & CTLR1_8BIT_FIELDS) != 0x00)
000012  780c              LDRB     r4,[r1,#0]
;;;145        {
;;;146            tempreg = GPIOx->CTLR1;
;;;147            for (pinpos = 0x00; pinpos < 0x08; pinpos++)
;;;148            {
;;;149                pos = ((uint32_t)0x01) << pinpos;
;;;150                /* Get the port pins position */
;;;151                currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
;;;152                if (currentpin == pos)
;;;153                {
;;;154                    pos = pinpos << 2;
;;;155                    /* Clear the corresponding low control register bits */
;;;156                    pinmask = ((uint32_t)0x0F) << pos;
000014  f04f0c0f          MOV      r12,#0xf
000018  f0140fff          TST      r4,#0xff              ;144
00001c  f04f0e01          MOV      lr,#1                 ;149
000020  d01b              BEQ      |L7.90|
000022  6805              LDR      r5,[r0,#0]            ;146
                  |L7.36|
000024  880e              LDRH     r6,[r1,#0]            ;151
000026  fa0ef402          LSL      r4,lr,r2              ;149
00002a  4026              ANDS     r6,r6,r4              ;151
00002c  42a6              CMP      r6,r4                 ;152
00002e  d110              BNE      |L7.82|
000030  0096              LSLS     r6,r2,#2              ;154
000032  fa0cf706          LSL      r7,r12,r6
;;;157                    tempreg &= ~pinmask;
000036  ea250707          BIC      r7,r5,r7
;;;158                    /* Write the mode configuration in the corresponding bits */
;;;159                    tempreg |= (currentmode << pos);
00003a  fa03f506          LSL      r5,r3,r6
;;;160                    /* Reset the corresponding ODR bit */
;;;161                    if (GPIO_InitStruct->GPIO_Mode == GPIO_MODE_IPD)
00003e  78ce              LDRB     r6,[r1,#3]
000040  433d              ORRS     r5,r5,r7              ;159
000042  2e28              CMP      r6,#0x28
000044  d002              BEQ      |L7.76|
;;;162                    {
;;;163                        GPIOx->BCR = (((uint32_t)0x01) << pinpos);
;;;164                    }
;;;165                    else
;;;166                    {
;;;167                        /* Set the corresponding ODR bit */
;;;168                        if (GPIO_InitStruct->GPIO_Mode == GPIO_MODE_IPU)
000046  2e48              CMP      r6,#0x48
000048  d002              BEQ      |L7.80|
00004a  e002              B        |L7.82|
                  |L7.76|
00004c  6144              STR      r4,[r0,#0x14]         ;163
00004e  e000              B        |L7.82|
                  |L7.80|
;;;169                        {
;;;170                            GPIOx->BOR = (((uint32_t)0x01) << pinpos);
000050  6104              STR      r4,[r0,#0x10]
                  |L7.82|
000052  1c52              ADDS     r2,r2,#1
000054  2a08              CMP      r2,#8                 ;147
000056  d3e5              BCC      |L7.36|
;;;171                        }
;;;172                    }
;;;173                }
;;;174            }
;;;175            GPIOx->CTLR1 = tempreg;
000058  6005              STR      r5,[r0,#0]
                  |L7.90|
;;;176        }
;;;177        /* GPIO CTLR2 Configuration */
;;;178        /* Configure the eight high port pins */
;;;179        if (GPIO_InitStruct->GPIO_Pin > CTLR2_8BIT_FIELDS)
00005a  880a              LDRH     r2,[r1,#0]
00005c  2aff              CMP      r2,#0xff
00005e  d91c              BLS      |L7.154|
;;;180        {
;;;181            tempreg = GPIOx->CTLR2;
000060  6844              LDR      r4,[r0,#4]
;;;182            for (pinpos = 0x00; pinpos < 0x08; pinpos++)
000062  2200              MOVS     r2,#0
                  |L7.100|
;;;183            {
;;;184                pos = (((uint32_t)0x01) << (pinpos + 0x08));
000064  f1020608          ADD      r6,r2,#8
000068  fa0ef506          LSL      r5,lr,r6
;;;185                /* Get the port pins position */
;;;186                currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
00006c  880e              LDRH     r6,[r1,#0]
00006e  402e              ANDS     r6,r6,r5
;;;187                if (currentpin == pos)
000070  42ae              CMP      r6,r5
000072  d10e              BNE      |L7.146|
;;;188                {
;;;189                    pos = pinpos << 2;
000074  0096              LSLS     r6,r2,#2
;;;190                    /* Clear the corresponding high control register bits */
;;;191                    pinmask = ((uint32_t)0x0F) << pos;
000076  fa0cf706          LSL      r7,r12,r6
;;;192                    tempreg &= ~pinmask;
00007a  43bc              BICS     r4,r4,r7
;;;193                    /* Write the mode configuration in the corresponding bits */
;;;194                    tempreg |= (currentmode << pos);
00007c  fa03f706          LSL      r7,r3,r6
;;;195                    /* Reset the corresponding DOR bit */
;;;196                    if (GPIO_InitStruct->GPIO_Mode == GPIO_MODE_IPD)
000080  78ce              LDRB     r6,[r1,#3]
000082  433c              ORRS     r4,r4,r7              ;194
000084  2e28              CMP      r6,#0x28
000086  d100              BNE      |L7.138|
;;;197                    {
;;;198                        GPIOx->BCR = (((uint32_t)0x01) << (pinpos + 0x08));
000088  6145              STR      r5,[r0,#0x14]
                  |L7.138|
;;;199                    }
;;;200                    /* Set the corresponding DOR bit */
;;;201                    if (GPIO_InitStruct->GPIO_Mode == GPIO_MODE_IPU)
00008a  78ce              LDRB     r6,[r1,#3]
00008c  2e48              CMP      r6,#0x48
00008e  d100              BNE      |L7.146|
;;;202                    {
;;;203                        GPIOx->BOR = (((uint32_t)0x01) << (pinpos + 0x08));
000090  6105              STR      r5,[r0,#0x10]
                  |L7.146|
000092  1c52              ADDS     r2,r2,#1
000094  2a08              CMP      r2,#8                 ;182
000096  d3e5              BCC      |L7.100|
;;;204                    }
;;;205                }
;;;206            }
;;;207            GPIOx->CTLR2 = tempreg;
000098  6044              STR      r4,[r0,#4]
                  |L7.154|
;;;208        }
;;;209    }
00009a  bdf0              POP      {r4-r7,pc}
;;;210    
                          ENDP


                          AREA ||i.GPIO_ParaInit||, CODE, READONLY, ALIGN=1

                  GPIO_ParaInit PROC
;;;215      */
;;;216    void GPIO_ParaInit(GPIO_InitPara* GPIO_InitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;217    {
;;;218        /* Reset GPIO init structure parameters values */
;;;219        GPIO_InitStruct->GPIO_Pin  = GPIO_PIN_ALL;
000004  8001              STRH     r1,[r0,#0]
;;;220        GPIO_InitStruct->GPIO_Speed = GPIO_SPEED_2MHZ;
000006  2102              MOVS     r1,#2
000008  7081              STRB     r1,[r0,#2]
;;;221        GPIO_InitStruct->GPIO_Mode = GPIO_MODE_IN_FLOATING;
00000a  2104              MOVS     r1,#4
00000c  70c1              STRB     r1,[r0,#3]
;;;222    }
00000e  4770              BX       lr
;;;223    
                          ENDP


                          AREA ||i.GPIO_PinLockConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinLockConfig PROC
;;;345      */
;;;346    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  f4413280          ORR      r2,r1,#0x10000
;;;347    {
;;;348        uint32_t temp = 0x00010000;
;;;349    
;;;350        temp |= GPIO_Pin;
;;;351        /* Set LCKK bit */
;;;352        GPIOx->LOCKR = temp;
000004  6182              STR      r2,[r0,#0x18]
;;;353        /* Reset LCKK bit */
;;;354        GPIOx->LOCKR =  GPIO_Pin;
000006  6181              STR      r1,[r0,#0x18]
;;;355        /* Set LCKK bit */
;;;356        GPIOx->LOCKR = temp;
000008  6182              STR      r2,[r0,#0x18]
;;;357        /* Read LCKK bit*/
;;;358        temp = GPIOx->LOCKR;
00000a  6981              LDR      r1,[r0,#0x18]
;;;359        /* Read LCKK bit*/
;;;360        temp = GPIOx->LOCKR;
00000c  6980              LDR      r0,[r0,#0x18]
;;;361    }
00000e  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.GPIO_PinRemapConfig||, CODE, READONLY, ALIGN=2

                  GPIO_PinRemapConfig PROC
;;;452      */
;;;453    void GPIO_PinRemapConfig(uint32_t GPIO_Remap, TypeState NewState)
000000  b5f0              PUSH     {r4-r7,lr}
;;;454    {
;;;455        uint32_t temp = 0x00, temp1 = 0x00, tempreg = 0x00, tempmask = 0x00;
;;;456    
;;;457        if((GPIO_Remap & 0x80000000) == 0x80000000)
;;;458        {
;;;459            tempreg = AFIO->AFIO_PCFR2;
000002  4c14              LDR      r4,|L10.84|
000004  2800              CMP      r0,#0                 ;457
000006  da01              BGE      |L10.12|
000008  69e3              LDR      r3,[r4,#0x1c]
00000a  e000              B        |L10.14|
                  |L10.12|
;;;460        }
;;;461        else
;;;462        {
;;;463            tempreg = AFIO->AFIO_PCFR1;
00000c  6863              LDR      r3,[r4,#4]
                  |L10.14|
;;;464        }
;;;465    
;;;466        tempmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
;;;467        temp = GPIO_Remap & LSB_MASK;
;;;468    
;;;469        if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
;;;470        {
;;;471            tempreg &= DBGAFR_SWJCFG_MASK;
;;;472            AFIO->AFIO_PCFR1 &= DBGAFR_SWJCFG_MASK;
;;;473        }
;;;474        else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
;;;475        {
;;;476            temp1 = ((uint32_t)0x03) << tempmask;
;;;477            tempreg &= ~temp1;
;;;478            tempreg |= ~DBGAFR_SWJCFG_MASK;
;;;479        }
;;;480        else
;;;481        {
;;;482            tempreg &= ~(temp << ((GPIO_Remap >> 0x15)*0x10));
00000e  0d45              LSRS     r5,r0,#21
000010  012e              LSLS     r6,r5,#4
000012  b285              UXTH     r5,r0                 ;467
000014  f3c05701          UBFX     r7,r0,#20,#2          ;469
000018  40b5              LSLS     r5,r5,r6
00001a  f3c04203          UBFX     r2,r0,#16,#4          ;466
00001e  2f03              CMP      r7,#3                 ;469
000020  d005              BEQ      |L10.46|
000022  02c6              LSLS     r6,r0,#11             ;474
000024  d50a              BPL      |L10.60|
000026  2603              MOVS     r6,#3                 ;476
000028  4096              LSLS     r6,r6,r2              ;476
00002a  43b3              BICS     r3,r3,r6              ;477
00002c  e007              B        |L10.62|
                  |L10.46|
00002e  f0236270          BIC      r2,r3,#0xf000000      ;471
000032  6863              LDR      r3,[r4,#4]            ;472
000034  f0236370          BIC      r3,r3,#0xf000000      ;472
000038  6063              STR      r3,[r4,#4]            ;472
00003a  e002              B        |L10.66|
                  |L10.60|
00003c  43ab              BICS     r3,r3,r5
                  |L10.62|
00003e  f0436270          ORR      r2,r3,#0xf000000      ;478
                  |L10.66|
;;;483            tempreg |= ~DBGAFR_SWJCFG_MASK;
;;;484        }
;;;485        if (NewState != DISABLE)
000042  b101              CBZ      r1,|L10.70|
;;;486        {
;;;487            tempreg |= (temp << ((GPIO_Remap >> 0x15)*0x10));
000044  432a              ORRS     r2,r2,r5
                  |L10.70|
;;;488        }
;;;489        if((GPIO_Remap & AFIO_PCFR2_FIELDS) == AFIO_PCFR2_FIELDS)
000046  2800              CMP      r0,#0
000048  da01              BGE      |L10.78|
;;;490        {
;;;491            AFIO->AFIO_PCFR2 = tempreg;
00004a  61e2              STR      r2,[r4,#0x1c]
;;;492        }
;;;493        else
;;;494        {
;;;495            AFIO->AFIO_PCFR1 = tempreg;
;;;496        }
;;;497    }
00004c  bdf0              POP      {r4-r7,pc}
                  |L10.78|
00004e  6062              STR      r2,[r4,#4]            ;495
000050  bdf0              POP      {r4-r7,pc}
;;;498    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      0x40010000

                          AREA ||i.GPIO_ReadInputBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputBit PROC
;;;229      */
;;;230    uint8_t GPIO_ReadInputBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;231    {
;;;232        uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;233    
;;;234        if ((GPIOx->DIR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  6892              LDR      r2,[r2,#8]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L11.12|
;;;235        {
;;;236            bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
                  |L11.12|
;;;237        }
;;;238        else
;;;239        {
;;;240            bitstatus = (uint8_t)Bit_RESET;
;;;241        }
;;;242        return bitstatus;
;;;243    }
00000c  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.GPIO_ReadInputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputData PROC
;;;249      */
;;;250    uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000000  6880              LDR      r0,[r0,#8]
;;;251    {
;;;252        return ((uint16_t)GPIOx->DIR);
000002  b280              UXTH     r0,r0
;;;253    }
000004  4770              BX       lr
;;;254    
                          ENDP


                          AREA ||i.GPIO_ReadOutputBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputBit PROC
;;;260      */
;;;261    uint8_t GPIO_ReadOutputBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;262    {
;;;263        uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;264    
;;;265        if ((GPIOx->DOR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  68d2              LDR      r2,[r2,#0xc]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L13.12|
;;;266        {
;;;267            bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
                  |L13.12|
;;;268        }
;;;269        else
;;;270        {
;;;271            bitstatus = (uint8_t)Bit_RESET;
;;;272        }
;;;273        return bitstatus;
;;;274    }
00000c  4770              BX       lr
;;;275    
                          ENDP


                          AREA ||i.GPIO_ReadOutputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputData PROC
;;;280      */
;;;281    uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000000  68c0              LDR      r0,[r0,#0xc]
;;;282    {
;;;283        return ((uint16_t)GPIOx->DOR);
000002  b280              UXTH     r0,r0
;;;284    }
000004  4770              BX       lr
;;;285    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;302      */
;;;303    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6141              STR      r1,[r0,#0x14]
;;;304    {
;;;305        GPIOx->BCR = GPIO_Pin;
;;;306    }
000002  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;291      */
;;;292    void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6101              STR      r1,[r0,#0x10]
;;;293    {
;;;294        GPIOx->BOR = GPIO_Pin;
;;;295    }
000002  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;316      */
;;;317    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitState BitVal)
000000  b10a              CBZ      r2,|L17.6|
;;;318    {
;;;319        if (BitVal != Bit_RESET)
;;;320        {
;;;321            GPIOx->BOR = GPIO_Pin;
000002  6101              STR      r1,[r0,#0x10]
;;;322        }
;;;323        else
;;;324        {
;;;325            GPIOx->BCR = GPIO_Pin;
;;;326        }
;;;327    }
000004  4770              BX       lr
                  |L17.6|
000006  6141              STR      r1,[r0,#0x14]         ;325
000008  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.GPIO_WritePort||, CODE, READONLY, ALIGN=1

                  GPIO_WritePort PROC
;;;334      */
;;;335    void GPIO_WritePort(GPIO_TypeDef* GPIOx, uint16_t PortVal)
000000  60c1              STR      r1,[r0,#0xc]
;;;336    {
;;;337        GPIOx->DOR = PortVal;
;;;338    }
000002  4770              BX       lr
;;;339    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\GIGA32\\gd32\\peripherals\\src\\gd32f10x_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_gd32f10x_gpio_c_f8e8e39a____REV16|
#line 129 "..\\..\\cmsis-core\\core_cmInstr.h"
|__asm___15_gd32f10x_gpio_c_f8e8e39a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_gd32f10x_gpio_c_f8e8e39a____REVSH|
#line 144
|__asm___15_gd32f10x_gpio_c_f8e8e39a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
