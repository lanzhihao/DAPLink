; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\gd32f10x_rcc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gd32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\startup -I..\..\cmsis-core -I..\src -I..\..\GIGA32\inc -I..\..\GIGA32\src -I..\..\GIGA32\gd32\peripherals\inc -I..\..\GIGA32\gd32\peripherals\src -I.\RTE\_Target_1 -IF:\software\mdk\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\software\mdk\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD -DDAPLINK_VERSION=242 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DINTERFACE_GD32F103 -DCPU_GD32F103CBT6 -DDAPLINK_HIC_ID=0x97969905 -DBL_TARGET_FLASH -DUSE_STDPERIPH_DRIVER -DGD32F10X_MD -DUSE_HSE_16MHZ --omf_browse=.\objects\gd32f10x_rcc.crf ..\..\GIGA32\gd32\peripherals\src\gd32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;572      */
;;;573    void RCC_ADCCLKConfig(uint32_t RCC_ADCCLK)
000000  4904              LDR      r1,|L1.20|
;;;574    { 
;;;575        
;;;576        /* Clear ADCPS bit */
;;;577        RCC->GCFGR &= ~RCC_GCFGR_ADCPS;
000002  684a              LDR      r2,[r1,#4]
000004  4b04              LDR      r3,|L1.24|
000006  401a              ANDS     r2,r2,r3
000008  604a              STR      r2,[r1,#4]
;;;578        /* Set ADCPS bits according to RCC_APB2 value */
;;;579        RCC->GCFGR |= RCC_ADCCLK;
00000a  684a              LDR      r2,[r1,#4]
00000c  4302              ORRS     r2,r2,r0
00000e  604a              STR      r2,[r1,#4]
;;;580    }
000010  4770              BX       lr
;;;581    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40021000
                  |L1.24|
                          DCD      0xefff3fff

                          AREA ||i.RCC_AHBConfig||, CODE, READONLY, ALIGN=2

                  RCC_AHBConfig PROC
;;;443      */
;;;444    void RCC_AHBConfig(uint32_t RCC_CK_SYSDiv)
000000  4a03              LDR      r2,|L2.16|
;;;445    {
;;;446        uint32_t temp = 0;
;;;447        
;;;448        temp = RCC->GCFGR;
000002  6851              LDR      r1,[r2,#4]
;;;449        
;;;450        /* Clear AHBPS[3:0] bits */
;;;451        temp &= ~RCC_GCFGR_AHBPS;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;452        
;;;453        /* Set AHBPS[3:0] bits according to RCC_CK_SYSDiv value */
;;;454        temp |= RCC_CK_SYSDiv;
000008  4301              ORRS     r1,r1,r0
;;;455        
;;;456        /* Store the new value */
;;;457        RCC->GCFGR = temp;
00000a  6051              STR      r1,[r2,#4]
;;;458    }
00000c  4770              BX       lr
;;;459    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClock_Enable||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClock_Enable PROC
;;;891      */
;;;892    void RCC_AHBPeriphClock_Enable(uint32_t RCC_AHBPeriph, TypeState NewValue)
000000  4a04              LDR      r2,|L3.20|
;;;893    {
;;;894      
;;;895        if (NewValue != DISABLE)
000002  2900              CMP      r1,#0
;;;896        {
;;;897            RCC->AHBCCR |= RCC_AHBPeriph;
;;;898        }
;;;899        else
;;;900        {
;;;901            RCC->AHBCCR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;897
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  6151              STR      r1,[r2,#0x14]         ;897
;;;902        }
;;;903    }
000010  4770              BX       lr
;;;904    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1Config||, CODE, READONLY, ALIGN=2

                  RCC_APB1Config PROC
;;;471      */
;;;472    void RCC_APB1Config(uint32_t RCC_APB1)
000000  4a03              LDR      r2,|L4.16|
;;;473    {
;;;474        uint32_t temp = 0;
;;;475        
;;;476        temp = RCC->GCFGR;
000002  6851              LDR      r1,[r2,#4]
;;;477        
;;;478        /* Clear APB1PS[2:0] bits */
;;;479        temp &= ~RCC_GCFGR_APB1PS;
000004  f42161e0          BIC      r1,r1,#0x700
;;;480        
;;;481        /* Set APB1PS[2:0] bits according to RCC_APB1 value */
;;;482        temp |= RCC_APB1;
000008  4301              ORRS     r1,r1,r0
;;;483        
;;;484        /* Store the new value */
;;;485        RCC->GCFGR = temp;
00000a  6051              STR      r1,[r2,#4]
;;;486    }
00000c  4770              BX       lr
;;;487    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClock_Enable||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClock_Enable PROC
;;;974      */
;;;975    void RCC_APB1PeriphClock_Enable(uint32_t RCC_APB1Periph, TypeState NewValue)
000000  4a04              LDR      r2,|L5.20|
;;;976    {
;;;977        if (NewValue != DISABLE)
000002  2900              CMP      r1,#0
;;;978        {
;;;979            RCC->APB1CCR |= RCC_APB1Periph;
;;;980        }
;;;981        else
;;;982        {
;;;983            RCC->APB1CCR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;979
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;979
;;;984        }
;;;985    }
000010  4770              BX       lr
;;;986    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphReset_Enable||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphReset_Enable PROC
;;;1081     */
;;;1082   void RCC_APB1PeriphReset_Enable(uint32_t RCC_APB1PeriphRST, TypeState NewValue)
000000  4a04              LDR      r2,|L6.20|
;;;1083   {
;;;1084       if (NewValue != DISABLE)
000002  2900              CMP      r1,#0
;;;1085       {
;;;1086           RCC->APB1RCR |= RCC_APB1PeriphRST;
;;;1087       }
;;;1088       else
;;;1089       {
;;;1090           RCC->APB1RCR &= ~RCC_APB1PeriphRST;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1086
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6111              STR      r1,[r2,#0x10]         ;1086
;;;1091       }
;;;1092   }
000010  4770              BX       lr
;;;1093   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2Config||, CODE, READONLY, ALIGN=2

                  RCC_APB2Config PROC
;;;499      */
;;;500    void RCC_APB2Config(uint32_t RCC_APB2)
000000  4a03              LDR      r2,|L7.16|
;;;501    {
;;;502        uint32_t temp = 0;
;;;503        
;;;504        temp = RCC->GCFGR;
000002  6851              LDR      r1,[r2,#4]
;;;505        
;;;506        /* Clear APB2PS[2:0] bits */
;;;507        temp &= ~RCC_GCFGR_APB2PS;
000004  f4215160          BIC      r1,r1,#0x3800
;;;508        
;;;509        /* Set APB2PS[2:0] bits according to RCC_APB2 value */
;;;510        temp |= RCC_APB2;
000008  4301              ORRS     r1,r1,r0
;;;511        
;;;512        /* Store the new value */
;;;513        RCC->GCFGR = temp;
00000a  6051              STR      r1,[r2,#4]
;;;514    }
00000c  4770              BX       lr
;;;515    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClock_Enable||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClock_Enable PROC
;;;930      */
;;;931    void RCC_APB2PeriphClock_Enable(uint32_t RCC_APB2Periph, TypeState NewValue)
000000  4a04              LDR      r2,|L8.20|
;;;932    {
;;;933        if (NewValue != DISABLE)
000002  2900              CMP      r1,#0
;;;934        {
;;;935            RCC->APB2CCR |= RCC_APB2Periph;
;;;936        }
;;;937        else
;;;938        {
;;;939            RCC->APB2CCR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  d001              BEQ      |L8.12|
000008  4301              ORRS     r1,r1,r0              ;935
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  4381              BICS     r1,r1,r0
                  |L8.14|
00000e  6191              STR      r1,[r2,#0x18]         ;935
;;;940        }
;;;941    }
000010  4770              BX       lr
;;;942    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphReset_Enable||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphReset_Enable PROC
;;;1036     */
;;;1037   void RCC_APB2PeriphReset_Enable(uint32_t RCC_APB2PeriphRST, TypeState NewValue)
000000  4a04              LDR      r2,|L9.20|
;;;1038   {
;;;1039   
;;;1040       if (NewValue != DISABLE)
000002  2900              CMP      r1,#0
;;;1041       {
;;;1042           RCC->APB2RCR |= RCC_APB2PeriphRST;
;;;1043       }
;;;1044       else
;;;1045       {
;;;1046           RCC->APB2RCR &= ~RCC_APB2PeriphRST;
000004  68d1              LDR      r1,[r2,#0xc]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;1042
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  60d1              STR      r1,[r2,#0xc]          ;1042
;;;1047       }
;;;1048   }
000010  4770              BX       lr
;;;1049   
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;186      */
;;;187    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4a03              LDR      r2,|L10.16|
;;;188    {
;;;189        uint32_t temp_adjust = 0;
;;;190        
;;;191        temp_adjust = RCC->GCCR;
000002  6811              LDR      r1,[r2,#0]
;;;192        
;;;193        /* Clear HSIADJ[4:0] bits */
;;;194        temp_adjust &= ~RCC_GCCR_HSIADJ;
000004  f02101f8          BIC      r1,r1,#0xf8
;;;195        
;;;196        /* Set HSIADJ[4:0] bits according to HSICalibrationValue value */
;;;197        temp_adjust |= (uint32_t)HSICalibrationValue << GCCR_HSIADJ_OFFSET ;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;198        
;;;199        /* Store the calibration value */
;;;200        RCC->GCCR = temp_adjust;
00000c  6010              STR      r0,[r2,#0]
;;;201    }
00000e  4770              BX       lr
;;;202    
                          ENDP

                  |L10.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupReset_Enable||, CODE, READONLY, ALIGN=2

                  RCC_BackupReset_Enable PROC
;;;1098     */
;;;1099   void RCC_BackupReset_Enable(TypeState NewValue)
000000  4905              LDR      r1,|L11.24|
;;;1100   {
;;;1101     
;;;1102       if (NewValue != DISABLE)
000002  2800              CMP      r0,#0
;;;1103       {
;;;1104           RCC->BDCR |= RCC_BDCR_BKPRST;
;;;1105       }
;;;1106       else
;;;1107       {
;;;1108           RCC->BDCR &= ~RCC_BDCR_BKPRST;
000004  6a08              LDR      r0,[r1,#0x20]
000006  d002              BEQ      |L11.14|
000008  f4403080          ORR      r0,r0,#0x10000        ;1104
00000c  e001              B        |L11.18|
                  |L11.14|
00000e  f4203080          BIC      r0,r0,#0x10000
                  |L11.18|
000012  6208              STR      r0,[r1,#0x20]         ;1104
;;;1109       }
;;;1110   }
000014  4770              BX       lr
;;;1111   
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40021000

                          AREA ||i.RCC_CKOUTSRCConfig||, CODE, READONLY, ALIGN=2

                  RCC_CKOUTSRCConfig PROC
;;;1152   
;;;1153   void RCC_CKOUTSRCConfig(uint32_t RCC_CKOUTSRC)
000000  4a03              LDR      r2,|L12.16|
;;;1154   {
;;;1155       uint32_t temp = 0;
;;;1156       
;;;1157       temp = RCC->GCFGR;
000002  6851              LDR      r1,[r2,#4]
;;;1158       /* Clear CKOUTSRC[2:0] bits */
;;;1159       temp &= ~(RCC_GCFGR_CKOUTSEL);
000004  f02161e0          BIC      r1,r1,#0x7000000
;;;1160       /* Set the RCC_CKOUTSRC */
;;;1161       temp |= RCC_CKOUTSRC;
000008  4301              ORRS     r1,r1,r0
;;;1162       /* Store the new value */
;;;1163       RCC->GCFGR = temp;
00000a  6051              STR      r1,[r2,#4]
;;;1164   }
00000c  4770              BX       lr
;;;1165   
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x40021000

                          AREA ||i.RCC_CK_SYSConfig||, CODE, READONLY, ALIGN=2

                  RCC_CK_SYSConfig PROC
;;;398      */
;;;399    void RCC_CK_SYSConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L13.16|
;;;400    {
;;;401        uint32_t temp = 0;
;;;402        
;;;403        temp = RCC->GCFGR;
000002  6851              LDR      r1,[r2,#4]
;;;404        
;;;405        /* Clear SCS[1:0] bits */
;;;406        temp &= ~RCC_GCFGR_SCS;
000004  f0210103          BIC      r1,r1,#3
;;;407        
;;;408        /* Set SCS[1:0] bits according to RCC_SYSCLKSource value */
;;;409        temp |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;410        
;;;411        /* Store the new value */
;;;412        RCC->GCFGR = temp;
00000a  6051              STR      r1,[r2,#4]
;;;413    }
00000c  4770              BX       lr
;;;414    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearBitState||, CODE, READONLY, ALIGN=2

                  RCC_ClearBitState PROC
;;;1280     */
;;;1281   void RCC_ClearBitState(void)
000000  4802              LDR      r0,|L14.12|
;;;1282   {
;;;1283       /* Set RSTFC bit to clear all reset flags */
;;;1284       RCC->GCSR |= RCC_GCSR_RSTFC;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1285   }
00000a  4770              BX       lr
;;;1286   
                          ENDP

                  |L14.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearIntBitState||, CODE, READONLY, ALIGN=2

                  RCC_ClearIntBitState PROC
;;;1345   
;;;1346   void RCC_ClearIntBitState(uint8_t RCC_INT)
000000  4901              LDR      r1,|L15.8|
;;;1347   {
;;;1348    
;;;1349     
;;;1350       /* Perform RCC_GCIR[23:16] bits to clear the selected interrupt bits */
;;;1351       *(__IO uint8_t *) GCIR_BYTE2_ADDRESS = RCC_INT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1352   }
000004  4770              BX       lr
;;;1353   
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x40021000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;95       */
;;;96     void RCC_DeInit(void)
000000  480c              LDR      r0,|L16.52|
;;;97     {
;;;98         /* Set RCC GCCR_HSIEN mask */
;;;99         RCC->GCCR |= GCCR_HSIEN_SET;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;100        
;;;101        /* Reset SCS[1:0], AHBPS[3:0], APB1PS[2:0],APB2PS[2:0], ADCPS[2:0],CKOTUSEL[2:0] bits */
;;;102    #ifdef GD32F10X_CL
;;;103        RCC->GCFGR &= GCFGR_RESET_CL;
;;;104    #else
;;;105        RCC->GCFGR &= GCFGR_RESET;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0a              LDR      r2,|L16.56|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;106    #endif /* GD32F10X_CL */   
;;;107      
;;;108        /* Reset HSEEN, CKMEN and PLLEN bits */
;;;109        RCC->GCCR &= GCCR_HSEEN_CKMEN_PLLEN_RESET;
000012  6801              LDR      r1,[r0,#0]
000014  4a09              LDR      r2,|L16.60|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;110    
;;;111        /* Reset HSEBPS bit */
;;;112        RCC->GCCR &= GCCR_HSEBPS_RESET;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;113    
;;;114        /* Reset PLLSEL, PLLPREDV and PLLMF[4:0] USBPS/OTGFSPS bits */
;;;115    #ifdef GD32F10X_CL
;;;116        RCC->GCFGR &= GCFGR_PLLSEL_PLLPREDV_PLLMF_OTGFSPS_RESET_CL;
;;;117    #else
;;;118        RCC->GCFGR &= GCFGR_PLLSEL_PLLPREDV_PLLMF_USBPS_RESET;
000022  6841              LDR      r1,[r0,#4]
000024  4a06              LDR      r2,|L16.64|
000026  4011              ANDS     r1,r1,r2
000028  6041              STR      r1,[r0,#4]
;;;119    #endif /* GD32F10X_CL */   
;;;120        
;;;121    #ifdef GD32F10X_CL
;;;122        /* Reset PLL2EN and PLL3EN bits */
;;;123        RCC->GCCR &= GCCR_PLL2EN_PLL3EN_RESET;
;;;124    
;;;125        /* Reset GCFGR2 register */
;;;126        RCC->GCFGR2 =GCFGR2_RESET ;
;;;127    
;;;128        /* Disable all interrupts and clear flag bits */
;;;129        RCC->GCIR = GCIR_INT_FLAG_RESET_CL;
;;;130    #else
;;;131        /* Disable all interrupts and clear flag bits */
;;;132        RCC->GCIR = GCIR_INT_FLAG_RESET;
00002a  f44f011f          MOV      r1,#0x9f0000
00002e  6081              STR      r1,[r0,#8]
;;;133    #endif /* GD32F10X_CL */   
;;;134    }
000030  4770              BX       lr
;;;135    
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      0x40021000
                  |L16.56|
                          DCD      0xe8ff0000
                  |L16.60|
                          DCD      0xfef6ffff
                  |L16.64|
                          DCD      0xf700ffff

                          AREA ||i.RCC_GetBitState||, CODE, READONLY, ALIGN=2

                  RCC_GetBitState PROC
;;;1236     */
;;;1237   TypeState RCC_GetBitState(uint8_t RCC_FLAG)
000000  0941              LSRS     r1,r0,#5
;;;1238   {
;;;1239       uint32_t temp = 0;                    
;;;1240       uint32_t statusreg = 0;
;;;1241   
;;;1242       /* Get the RCC register index */
;;;1243       temp = RCC_FLAG >> 5;
;;;1244       
;;;1245       /* The flag to check is in GCCR register */
;;;1246       if (temp == 1)              
;;;1247       {
;;;1248           statusreg = RCC->GCCR;
000002  4a0a              LDR      r2,|L17.44|
000004  2901              CMP      r1,#1                 ;1246
000006  d00a              BEQ      |L17.30|
;;;1249       }
;;;1250       
;;;1251       /* The flag to check is in BDCR register */
;;;1252       else if (temp == 2)          
000008  2902              CMP      r1,#2
00000a  d00a              BEQ      |L17.34|
;;;1253       {
;;;1254           statusreg = RCC->BDCR;
;;;1255       }
;;;1256       
;;;1257       /* The flag to check is in GCSR register */
;;;1258       else                       
;;;1259       {
;;;1260           statusreg = RCC->GCSR;
00000c  6a51              LDR      r1,[r2,#0x24]
                  |L17.14|
;;;1261       }
;;;1262   
;;;1263       /* Get the flag position */
;;;1264       temp = RCC_FLAG & FLAG_MASK;
00000e  f000001f          AND      r0,r0,#0x1f
;;;1265       if ((statusreg & ((uint32_t)(1 << temp))) != (uint32_t)RESET)
000012  2201              MOVS     r2,#1
000014  4082              LSLS     r2,r2,r0
000016  420a              TST      r2,r1
000018  d005              BEQ      |L17.38|
;;;1266       {
;;;1267           return SET;
00001a  2001              MOVS     r0,#1
;;;1268       }
;;;1269       else
;;;1270       {
;;;1271           return RESET;
;;;1272       }
;;;1273   
;;;1274   }
00001c  4770              BX       lr
                  |L17.30|
00001e  6811              LDR      r1,[r2,#0]            ;1248
000020  e7f5              B        |L17.14|
                  |L17.34|
000022  6a11              LDR      r1,[r2,#0x20]         ;1254
000024  e7f3              B        |L17.14|
                  |L17.38|
000026  2000              MOVS     r0,#0                 ;1271
000028  4770              BX       lr
;;;1275   
                          ENDP

00002a  0000              DCW      0x0000
                  |L17.44|
                          DCD      0x40021000

                          AREA ||i.RCC_GetCK_SYSSource||, CODE, READONLY, ALIGN=2

                  RCC_GetCK_SYSSource PROC
;;;423      */
;;;424    uint8_t RCC_GetCK_SYSSource(void)
000000  4802              LDR      r0,|L18.12|
;;;425    {
;;;426        return ((uint8_t)(RCC->GCFGR & RCC_GCFGR_SCSS));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;427    }
000008  4770              BX       lr
;;;428    /**
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0x40021000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;699      */
;;;700    void RCC_GetClocksFreq(RCC_ClocksPara* RCC_Clocks)
000000  b530              PUSH     {r4,r5,lr}
;;;701    {
;;;702        uint32_t temp = 0, pllmf = 0, pllmf4=0,pllselect = 0, presc = 0;
;;;703    
;;;704    #ifdef  GD32F10X_CL
;;;705        uint32_t prediv1select = 0, prediv1factor = 0, prediv2factor = 0, pll2mf = 0;
;;;706    #endif /* GD32F10X_CL */
;;;707    
;;;708        
;;;709        /* Get CK_SYS source */
;;;710        temp = RCC->GCFGR & RCC_GCFGR_SCSS;
000002  4a30              LDR      r2,|L19.196|
000004  6851              LDR      r1,[r2,#4]
;;;711      
;;;712        switch (temp)
;;;713        {
;;;714            case 0x00:  /* HSI used as CK_SYS */
;;;715            RCC_Clocks->CK_SYS_Frequency = HSI_VALUE;
000006  4b30              LDR      r3,|L19.200|
000008  f011010c          ANDS     r1,r1,#0xc            ;710
00000c  d003              BEQ      |L19.22|
00000e  2904              CMP      r1,#4                 ;712
000010  d003              BEQ      |L19.26|
000012  2908              CMP      r1,#8                 ;712
000014  d003              BEQ      |L19.30|
                  |L19.22|
;;;716            break;
000016  6003              STR      r3,[r0,#0]
000018  e01b              B        |L19.82|
                  |L19.26|
;;;717            case 0x04:  /* HSE used as CK_SYS */
;;;718            RCC_Clocks->CK_SYS_Frequency = HSE_VALUE;
00001a  492c              LDR      r1,|L19.204|
;;;719            break;
00001c  e018              B        |L19.80|
                  |L19.30|
;;;720            case 0x08:  /* PLL used as CK_SYS */
;;;721        #ifdef  GD32F10X_CL
;;;722            /* Get PLL clock source and multiplication factor */
;;;723            /* Get PLLMF[3:0] */
;;;724            pllmf = RCC->GCFGR & RCC_GCFGR_PLLMF_3_0;
;;;725            /* Get PLLMF[4] */
;;;726            pllmf4 = RCC->GCFGR & RCC_GCFGR_PLLMF_4;
;;;727    
;;;728            pllmf4 = (( pllmf4 >> 29)*15);
;;;729    
;;;730            pllmf = ( pllmf >> 18) + pllmf4;
;;;731            if (pllmf != 0x0D)
;;;732            {
;;;733                pllmf += 2;
;;;734            }
;;;735            else
;;;736            { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;737                pllmf = 13 / 2; 
;;;738            }
;;;739                    
;;;740            pllselect = RCC->GCFGR & RCC_GCFGR_PLLSEL;
;;;741            if (pllselect == 0x00)
;;;742            {
;;;743                /* HSI clock divided by 2 selected as PLL clock source */
;;;744                RCC_Clocks->CK_SYS_Frequency = (HSI_VALUE >>HSI_CLOCK_DIVIDED_2) * pllmf;
;;;745            }
;;;746            else
;;;747            {
;;;748                /* PREDIV1 selected as PLL clock entry */
;;;749                
;;;750                /* Get PREDIV1 clock source and division factor */
;;;751                prediv1select = RCC->GCFGR2 & RCC_GCFGR2_PREDV1SEL;
;;;752                prediv1factor = (RCC->GCFGR2 & RCC_GCFGR2_PREDV1) + 1;
;;;753                
;;;754                if (prediv1select == 0)
;;;755                {   /* HSE clock selected as PREDIV1 clock entry */
;;;756                    RCC_Clocks->CK_SYS_Frequency = (HSE_VALUE / prediv1factor) * pllmf;          
;;;757                }
;;;758                else
;;;759                {   /* PLL2 clock selected as PREDIV1 clock entry */
;;;760                    /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;761                    prediv2factor = ((RCC->GCFGR2 & RCC_GCFGR2_PREDV2) >> 4) + 1;
;;;762                    pll2mf = ((RCC->GCFGR2 & RCC_GCFGR2_PLL2MF) >> 8);
;;;763                    if(pll2mf != 15)
;;;764                    {
;;;765                        pll2mf += 2;
;;;766                    }
;;;767                    else
;;;768                    {
;;;769                        pll2mf += 5;
;;;770                    }
;;;771                    RCC_Clocks->CK_SYS_Frequency = (((HSE_VALUE / prediv2factor) * pll2mf) / prediv1factor) * pllmf;                         
;;;772                }
;;;773            }
;;;774        #else
;;;775            /* Get PLL clock source and multiplication factor */
;;;776            /* Get PLLMF[3:0] */
;;;777            pllmf = RCC->GCFGR & RCC_GCFGR_PLLMF_3_0;
00001e  6851              LDR      r1,[r2,#4]
000020  f4011370          AND      r3,r1,#0x3c0000
;;;778            /* Get PLLMF[4] */
;;;779            pllmf4 = RCC->GCFGR & RCC_GCFGR_PLLMF_4;
000024  6851              LDR      r1,[r2,#4]
;;;780    
;;;781            pllmf4 = (( pllmf4 >> 27)*15);
;;;782            pllmf = ( pllmf >> 18) + pllmf4+ 2;
;;;783    
;;;784                    
;;;785            pllselect = RCC->GCFGR & RCC_GCFGR_PLLSEL;
;;;786            if (pllselect == 0x00)
;;;787            {
;;;788                /* HSI clock divided by 2 selected as PLL clock source */
;;;789                RCC_Clocks->CK_SYS_Frequency = (HSI_VALUE >>HSI_CLOCK_DIVIDED_2) * pllmf;
;;;790            }
;;;791            else
;;;792            {
;;;793                if((RCC->GCFGR & RCC_GCFGR_PLLPREDV) != (uint32_t)RESET )
;;;794                {
;;;795                    /* HSE clock divided by 2 */
;;;796                    RCC_Clocks->CK_SYS_Frequency = (HSE_VALUE >> HSE_CLOCK_DIVIDED_2) * pllmf;
;;;797                }
;;;798                else
;;;799                {
;;;800                    RCC_Clocks->CK_SYS_Frequency = HSE_VALUE * pllmf;
;;;801                }
;;;802            }
;;;803        #endif/* GD32F10X_CL */
;;;804            break;
;;;805            default: /* HSI used as system clock */
;;;806            RCC_Clocks->CK_SYS_Frequency = HSI_VALUE;
;;;807            break;
;;;808        }
;;;809    
;;;810        /* Get AHB prescaler */
;;;811        temp = RCC->GCFGR & RCC_GCFGR_AHBPS;
;;;812        temp = temp >> 4;
;;;813        presc = AHBPrescTable[temp]; 
;;;814        /* Get AHB clock frequency */
;;;815        RCC_Clocks->AHB_Frequency = RCC_Clocks->CK_SYS_Frequency >> presc;
;;;816        
;;;817        /* Get APB1 prescaler */
;;;818        temp = RCC->GCFGR & RCC_GCFGR_APB1PS;
;;;819        temp = temp >> 8;
;;;820        presc = APBPrescTable[temp];
;;;821        /* Get APB1 clock frequency */
;;;822        RCC_Clocks->APB1_Frequency = RCC_Clocks->AHB_Frequency >> presc;
;;;823        
;;;824        /* Get APB2 prescaler */
;;;825        temp = RCC->GCFGR & RCC_GCFGR_APB2PS;
;;;826        temp = temp >> 11;
;;;827        presc = APBPrescTable[temp];
;;;828        /* Get APB2 clock frequency */
;;;829        RCC_Clocks->APB2_Frequency = RCC_Clocks->AHB_Frequency >> presc;
;;;830        
;;;831        /* Get ADCCLK clock frequency */
;;;832        temp = ((RCC->GCFGR & RCC_GCFGR_ADCPS_2) >>26);
;;;833        temp += ((RCC->GCFGR & (RCC_GCFGR_ADCPS_0 | RCC_GCFGR_ADCPS_1)) >>14);
;;;834        switch (temp)
;;;835        {
;;;836            case 0x00: /* ADC Clock is derived from APB2/2 */
;;;837            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /2);
;;;838            break;
;;;839            case 0x01: /* ADC Clock is derived from APB2/4 */
;;;840            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /4);
;;;841            break;
;;;842            case 0x02: /* ADC Clock is derived from APB2/6 */
;;;843            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /6);
;;;844            break;
;;;845            case 0x03: /* ADC Clock is derived from APB2/8 */
;;;846            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /8);
;;;847            break;
;;;848            case 0x04: /* ADC Clock is derived from APB2/2 */
;;;849            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /2);
;;;850            break;
;;;851            case 0x05: /* ADC Clock is derived from APB2/12 */
;;;852            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /12);
;;;853            break;
;;;854            case 0x06: /* ADC Clock is derived from APB2/8 */
;;;855            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /8);
;;;856            break;
;;;857            case 0x07: /* ADC Clock is derived from APB2/16 */
;;;858            RCC_Clocks->ADCCLK_Frequency = (RCC_Clocks->APB2_Frequency /16);
;;;859            break;
;;;860        }
;;;861    }
000026  2401              MOVS     r4,#1
000028  ea0461d1          AND      r1,r4,r1,LSR #27
00002c  ebc11101          RSB      r1,r1,r1,LSL #4       ;781
000030  eb014193          ADD      r1,r1,r3,LSR #18      ;782
000034  6853              LDR      r3,[r2,#4]            ;785
000036  1c89              ADDS     r1,r1,#2              ;785
000038  f4133f80          TST      r3,#0x10000           ;785
00003c  d004              BEQ      |L19.72|
00003e  6853              LDR      r3,[r2,#4]            ;793
000040  039b              LSLS     r3,r3,#14             ;793
000042  d503              BPL      |L19.76|
000044  4b20              LDR      r3,|L19.200|
000046  e002              B        |L19.78|
                  |L19.72|
000048  4b21              LDR      r3,|L19.208|
00004a  e000              B        |L19.78|
                  |L19.76|
00004c  4b1f              LDR      r3,|L19.204|
                  |L19.78|
00004e  4359              MULS     r1,r3,r1              ;796
                  |L19.80|
000050  6001              STR      r1,[r0,#0]            ;796
                  |L19.82|
000052  6851              LDR      r1,[r2,#4]            ;811
000054  230f              MOVS     r3,#0xf
000056  ea031111          AND      r1,r3,r1,LSR #4
00005a  4b1e              LDR      r3,|L19.212|
00005c  5c5b              LDRB     r3,[r3,r1]            ;813
00005e  6801              LDR      r1,[r0,#0]            ;815
000060  40d9              LSRS     r1,r1,r3              ;815
000062  6041              STR      r1,[r0,#4]            ;818
000064  6853              LDR      r3,[r2,#4]            ;818
000066  2507              MOVS     r5,#7
000068  4c1a              LDR      r4,|L19.212|
00006a  ea052313          AND      r3,r5,r3,LSR #8
00006e  3c08              SUBS     r4,r4,#8              ;820
000070  5ce3              LDRB     r3,[r4,r3]            ;820
000072  fa21f303          LSR      r3,r1,r3              ;822
000076  6083              STR      r3,[r0,#8]            ;825
000078  6853              LDR      r3,[r2,#4]            ;825
00007a  ea0523d3          AND      r3,r5,r3,LSR #11
00007e  5ce3              LDRB     r3,[r4,r3]            ;827
000080  40d9              LSRS     r1,r1,r3              ;829
000082  60c1              STR      r1,[r0,#0xc]          ;832
000084  6853              LDR      r3,[r2,#4]            ;832
000086  2404              MOVS     r4,#4
000088  6852              LDR      r2,[r2,#4]            ;833
00008a  ea046393          AND      r3,r4,r3,LSR #26
00008e  f3c23281          UBFX     r2,r2,#14,#2          ;833
000092  441a              ADD      r2,r2,r3              ;833
000094  2a08              CMP      r2,#8                 ;834
000096  d213              BCS      |L19.192|
000098  e8dff002          TBB      [pc,r2]               ;834
00009c  0406080a          DCB      0x04,0x06,0x08,0x0a
0000a0  040c0a10          DCB      0x04,0x0c,0x0a,0x10
0000a4  0849              LSRS     r1,r1,#1              ;837
0000a6  e00a              B        |L19.190|
0000a8  0889              LSRS     r1,r1,#2              ;840
0000aa  e008              B        |L19.190|
0000ac  2206              MOVS     r2,#6                 ;843
0000ae  e002              B        |L19.182|
0000b0  08c9              LSRS     r1,r1,#3              ;846
0000b2  e004              B        |L19.190|
0000b4  220c              MOVS     r2,#0xc               ;852
                  |L19.182|
0000b6  fbb1f1f2          UDIV     r1,r1,r2              ;843
0000ba  e000              B        |L19.190|
0000bc  0909              LSRS     r1,r1,#4              ;858
                  |L19.190|
0000be  6101              STR      r1,[r0,#0x10]         ;858
                  |L19.192|
0000c0  bd30              POP      {r4,r5,pc}
;;;862    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L19.196|
                          DCD      0x40021000
                  |L19.200|
                          DCD      0x007a1200
                  |L19.204|
                          DCD      0x00f42400
                  |L19.208|
                          DCD      0x003d0900
                  |L19.212|
                          DCD      ||.data||+0x8

                          AREA ||i.RCC_GetIntBitState||, CODE, READONLY, ALIGN=2

                  RCC_GetIntBitState PROC
;;;1309     */
;;;1310   TypeState RCC_GetIntBitState(uint8_t RCC_INT)
000000  4903              LDR      r1,|L20.16|
;;;1311   {  
;;;1312     /* Check the status of the RCC interrupt */
;;;1313       if ((RCC->GCIR & RCC_INT) != (uint32_t)RESET)
000002  6889              LDR      r1,[r1,#8]
000004  4201              TST      r1,r0
000006  d001              BEQ      |L20.12|
;;;1314       {
;;;1315           return SET;
000008  2001              MOVS     r0,#1
;;;1316       }
;;;1317       else
;;;1318       {
;;;1319           return RESET;
;;;1320       }
;;;1321   }
00000a  4770              BX       lr
                  |L20.12|
00000c  2000              MOVS     r0,#0                 ;1319
00000e  4770              BX       lr
;;;1322   /**
                          ENDP

                  |L20.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEClockMonitor_Enable||, CODE, READONLY, ALIGN=2

                  RCC_HSEClockMonitor_Enable PROC
;;;1117     */
;;;1118   void RCC_HSEClockMonitor_Enable(TypeState NewValue)
000000  4905              LDR      r1,|L21.24|
;;;1119   {
;;;1120       if (NewValue != DISABLE)
000002  2800              CMP      r0,#0
;;;1121       {
;;;1122           RCC->GCCR |= RCC_GCCR_CKMEN;
;;;1123       }
;;;1124       else
;;;1125       {
;;;1126           RCC->GCCR &= ~RCC_GCCR_CKMEN;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L21.14|
000008  f4402000          ORR      r0,r0,#0x80000        ;1122
00000c  e001              B        |L21.18|
                  |L21.14|
00000e  f4202000          BIC      r0,r0,#0x80000
                  |L21.18|
000012  6008              STR      r0,[r1,#0]            ;1122
;;;1127       }
;;;1128   }
000014  4770              BX       lr
;;;1129   
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;144      */
;;;145    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  4904              LDR      r1,|L22.20|
;;;146    {
;;;147        /* Reset HSEEN and HSEBPS bits */
;;;148        RCC->GCCR &= GCCR_HSEEN_HSEBPS_RESET;
000002  680a              LDR      r2,[r1,#0]
000004  f42222a0          BIC      r2,r2,#0x50000
000008  600a              STR      r2,[r1,#0]
;;;149        /* Set the new state of HSE */
;;;150        RCC->GCCR |= RCC_HSE;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;151    
;;;152    }
000010  4770              BX       lr
;;;153    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x40021000

                          AREA ||i.RCC_HSI_Enable||, CODE, READONLY, ALIGN=2

                  RCC_HSI_Enable PROC
;;;208      */
;;;209    void RCC_HSI_Enable(TypeState NewValue)
000000  4905              LDR      r1,|L23.24|
;;;210    {
;;;211      
;;;212        if (NewValue != DISABLE)
000002  2800              CMP      r0,#0
;;;213        {
;;;214            RCC->GCCR |= RCC_GCCR_HSIEN;
;;;215        }
;;;216        else
;;;217        {
;;;218            RCC->GCCR &= ~RCC_GCCR_HSIEN;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L23.14|
000008  f0400001          ORR      r0,r0,#1              ;214
00000c  e001              B        |L23.18|
                  |L23.14|
00000e  f0200001          BIC      r0,r0,#1
                  |L23.18|
000012  6008              STR      r0,[r1,#0]            ;214
;;;219        }
;;;220    }
000014  4770              BX       lr
;;;221    
                          ENDP

000016  0000              DCW      0x0000
                  |L23.24|
                          DCD      0x40021000

                          AREA ||i.RCC_INTConfig||, CODE, READONLY, ALIGN=2

                  RCC_INTConfig PROC
;;;1189     */
;;;1190   void RCC_INTConfig(uint8_t RCC_INT, TypeState NewValue)
000000  4a04              LDR      r2,|L24.20|
;;;1191   {  
;;;1192       if (NewValue != DISABLE)
000002  2900              CMP      r1,#0
;;;1193       {
;;;1194           /* Perform Byte access to RCC_GCIR[14:8] bits to enable the selected interrupts */
;;;1195           *(__IO uint8_t *) GCIR_BYTE1_ADDRESS |= RCC_INT;
;;;1196       }
;;;1197       else
;;;1198       {
;;;1199           /* Perform Byte access to RCC_GCIR bits to disable the selected interrupts */
;;;1200           *(__IO uint8_t *) GCIR_BYTE1_ADDRESS &= (uint8_t)~RCC_INT;
000004  7a51              LDRB     r1,[r2,#9]
000006  d001              BEQ      |L24.12|
000008  4301              ORRS     r1,r1,r0              ;1195
00000a  e000              B        |L24.14|
                  |L24.12|
00000c  4381              BICS     r1,r1,r0
                  |L24.14|
00000e  7251              STRB     r1,[r2,#9]            ;1195
;;;1201       }
;;;1202   }
000010  4770              BX       lr
;;;1203   
                          ENDP

000012  0000              DCW      0x0000
                  |L24.20|
                          DCD      0x40021000

                          AREA ||i.RCC_KERNELVOLConfig||, CODE, READONLY, ALIGN=2

                  RCC_KERNELVOLConfig PROC
;;;1364     */
;;;1365   void RCC_KERNELVOLConfig(uint32_t RCC_KERNEL_VOL) 
000000  4904              LDR      r1,|L25.20|
;;;1366   { 
;;;1367       /* Clear DEEPSLEEP_VC bit */
;;;1368       RCC->RCC_DEEPSLEEP_VC &= ~RCC_DEEPSLEEP_VC_CLEAR;
000002  6b4a              LDR      r2,[r1,#0x34]
000004  f0220203          BIC      r2,r2,#3
000008  634a              STR      r2,[r1,#0x34]
;;;1369       /* Set DEEPSLEEP_VC bits according to RCC_KERNEL_VOL value */
;;;1370       RCC->RCC_DEEPSLEEP_VC |= RCC_KERNEL_VOL;
00000a  6b4a              LDR      r2,[r1,#0x34]
00000c  4302              ORRS     r2,r2,r0
00000e  634a              STR      r2,[r1,#0x34]
;;;1371   }
000010  4770              BX       lr
;;;1372   
                          ENDP

000012  0000              DCW      0x0000
                  |L25.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;627      */
;;;628    void RCC_LSEConfig(uint32_t RCC_LSE)
000000  4906              LDR      r1,|L26.28|
;;;629    {
;;;630     
;;;631        /* Reset LSEEN and LSEBPS bits before configuring the LSE */
;;;632        RCC->BDCR &= ~(RCC_BDCR_LSEEN);
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
;;;633        RCC->BDCR &= ~(RCC_BDCR_LSEBPS);
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  f0220204          BIC      r2,r2,#4
000010  620a              STR      r2,[r1,#0x20]
;;;634        
;;;635        /* Configure LSE */
;;;636        RCC->BDCR |= RCC_LSE;
000012  6a0a              LDR      r2,[r1,#0x20]
000014  4302              ORRS     r2,r2,r0
000016  620a              STR      r2,[r1,#0x20]
;;;637    }
000018  4770              BX       lr
;;;638    
                          ENDP

00001a  0000              DCW      0x0000
                  |L26.28|
                          DCD      0x40021000

                          AREA ||i.RCC_LSI_Enable||, CODE, READONLY, ALIGN=2

                  RCC_LSI_Enable PROC
;;;645      */
;;;646    void RCC_LSI_Enable(TypeState NewValue)
000000  4905              LDR      r1,|L27.24|
;;;647    {
;;;648        
;;;649        if (NewValue != DISABLE)
000002  2800              CMP      r0,#0
;;;650        {
;;;651            RCC->GCSR |= RCC_GCSR_LSIEN;
;;;652        }
;;;653        else
;;;654        {
;;;655            RCC->GCSR &= ~RCC_GCSR_LSIEN;
000004  6a48              LDR      r0,[r1,#0x24]
000006  d002              BEQ      |L27.14|
000008  f0400001          ORR      r0,r0,#1              ;651
00000c  e001              B        |L27.18|
                  |L27.14|
00000e  f0200001          BIC      r0,r0,#1
                  |L27.18|
000012  6248              STR      r0,[r1,#0x24]         ;651
;;;656        }
;;;657    }
000014  4770              BX       lr
;;;658    
                          ENDP

000016  0000              DCW      0x0000
                  |L27.24|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;236      */
;;;237    void RCC_PLLConfig(uint32_t RCC_PLLSelect, uint32_t RCC_PLLMF)
000000  4b04              LDR      r3,|L28.20|
;;;238    {
000002  b510              PUSH     {r4,lr}
;;;239        uint32_t temp = 0;
;;;240    
;;;241        temp = RCC->GCFGR;
000004  685a              LDR      r2,[r3,#4]
;;;242        /* Clear PLLSEL [16] and PLLMF[4:0] bits */
;;;243        temp &= ~(RCC_GCFGR_PLLMF | RCC_GCFGR_PLLSEL);
000006  4c04              LDR      r4,|L28.24|
;;;244        /* Set the PLLSEL and PLLMF */
;;;245        temp |= RCC_PLLSelect | RCC_PLLMF;
000008  4308              ORRS     r0,r0,r1
00000a  4022              ANDS     r2,r2,r4              ;243
00000c  4310              ORRS     r0,r0,r2
;;;246    
;;;247        RCC->GCFGR = temp;
00000e  6058              STR      r0,[r3,#4]
;;;248    }
000010  bd10              POP      {r4,pc}
;;;249    
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      0x40021000
                  |L28.24|
                          DCD      0xf7c2ffff

                          AREA ||i.RCC_PLL_Enable||, CODE, READONLY, ALIGN=2

                  RCC_PLL_Enable PROC
;;;255      */
;;;256    void RCC_PLL_Enable(TypeState NewValue)
000000  4905              LDR      r1,|L29.24|
;;;257    {
;;;258        if (NewValue != DISABLE)
000002  2800              CMP      r0,#0
;;;259        {
;;;260            RCC->GCCR |= RCC_GCCR_PLLEN;
;;;261        }
;;;262        else
;;;263        {
;;;264            RCC->GCCR &= ~RCC_GCCR_PLLEN;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L29.14|
000008  f0407080          ORR      r0,r0,#0x1000000      ;260
00000c  e001              B        |L29.18|
                  |L29.14|
00000e  f0207080          BIC      r0,r0,#0x1000000
                  |L29.18|
000012  6008              STR      r0,[r1,#0]            ;260
;;;265        }
;;;266    }
000014  4770              BX       lr
;;;267    
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;668      */
;;;669    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4904              LDR      r1,|L30.20|
;;;670    {
;;;671        /* Clear RTCSEL bit */
;;;672        RCC->BDCR &= ~RCC_BDCR_RTCSEL;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f4227240          BIC      r2,r2,#0x300
000008  620a              STR      r2,[r1,#0x20]
;;;673        /* Select the RTC clock source */
;;;674        RCC->BDCR |= RCC_RTCCLKSource;
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  4302              ORRS     r2,r2,r0
00000e  620a              STR      r2,[r1,#0x20]
;;;675    }
000010  4770              BX       lr
;;;676    
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLK_Enable||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLK_Enable PROC
;;;682      */
;;;683    void RCC_RTCCLK_Enable(TypeState NewValue)		
000000  4905              LDR      r1,|L31.24|
;;;684    {
;;;685      
;;;686        if (NewValue != DISABLE)
000002  2800              CMP      r0,#0
;;;687        {
;;;688            RCC->BDCR |= RCC_BDCR_RTCEN;
;;;689        }
;;;690        else
;;;691        {
;;;692            RCC->BDCR &= ~RCC_BDCR_RTCEN;
000004  6a08              LDR      r0,[r1,#0x20]
000006  d002              BEQ      |L31.14|
000008  f4404000          ORR      r0,r0,#0x8000         ;688
00000c  e001              B        |L31.18|
                  |L31.14|
00000e  f4204000          BIC      r0,r0,#0x8000
                  |L31.18|
000012  6208              STR      r0,[r1,#0x20]         ;688
;;;693        }
;;;694    }
000014  4770              BX       lr
;;;695    
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;549      */
;;;550    void RCC_USBCLKConfig(uint32_t RCC_USBCLK)
000000  4904              LDR      r1,|L32.20|
;;;551    { 
;;;552        
;;;553        /* Clear USBPS bit */
;;;554        RCC->GCFGR &= ~RCC_GCFGR_USBPS;
000002  684a              LDR      r2,[r1,#4]
000004  f4220240          BIC      r2,r2,#0xc00000
000008  604a              STR      r2,[r1,#4]
;;;555        /* Set USBPS bits according to RCC_USBCLK value */
;;;556        RCC->GCFGR |= RCC_USBCLK;
00000a  684a              LDR      r2,[r1,#4]
00000c  4302              ORRS     r2,r2,r0
00000e  604a              STR      r2,[r1,#4]
;;;557     
;;;558    }
000010  4770              BX       lr
;;;559    #endif /* GD32F10X_CL */ 
                          ENDP

000012  0000              DCW      0x0000
                  |L32.20|
                          DCD      0x40021000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;158      */
;;;159    TypeState RCC_WaitForHSEStartUp(void)
000000  b508              PUSH     {r3,lr}
;;;160    {
;;;161        __IO uint32_t HSE_StartOk_Counter = 0;
000002  2000              MOVS     r0,#0
;;;162        TypeState HSEState = RESET;
;;;163        
;;;164        /* Wait until HSE is ready and if timeout to exit */
;;;165        while((HSE_StartOk_Counter != HSE_STARTUP_TIMEOUT) && (HSEState == RESET))
000004  f64f73ff          MOV      r3,#0xffff
000008  9000              STR      r0,[sp,#0]
                  |L33.10|
;;;166        {
;;;167            HSEState = RCC_GetBitState(RCC_FLAG_HSESTB);
00000a  2031              MOVS     r0,#0x31
00000c  f7fffffe          BL       RCC_GetBitState
;;;168            HSE_StartOk_Counter++;  
000010  9900              LDR      r1,[sp,#0]
000012  1c49              ADDS     r1,r1,#1
000014  9100              STR      r1,[sp,#0]            ;165
000016  4299              CMP      r1,r3                 ;165
000018  d001              BEQ      |L33.30|
00001a  2800              CMP      r0,#0                 ;165
00001c  d0f5              BEQ      |L33.10|
                  |L33.30|
;;;169        }
;;;170        
;;;171        if(RCC_GetBitState(RCC_FLAG_HSESTB) != RESET)
00001e  2031              MOVS     r0,#0x31
000020  f7fffffe          BL       RCC_GetBitState
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L33.42|
;;;172        {
;;;173            return SUCCESS;
000028  2001              MOVS     r0,#1
                  |L33.42|
;;;174        }
;;;175        else
;;;176        {
;;;177            return ERROR;
;;;178        }
;;;179    }
00002a  bd08              POP      {r3,pc}
;;;180    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
                  AHBPrescTable
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  01020304          DCB      0x01,0x02,0x03,0x04
000014  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\GIGA32\\gd32\\peripherals\\src\\gd32f10x_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_rcc_c_49e27980____REV16|
#line 129 "..\\..\\cmsis-core\\core_cmInstr.h"
|__asm___14_gd32f10x_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_gd32f10x_rcc_c_49e27980____REVSH|
#line 144
|__asm___14_gd32f10x_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
