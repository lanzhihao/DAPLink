; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\gd32f10x_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gd32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\startup -I..\..\cmsis-core -I..\src -I..\..\GIGA32\inc -I..\..\GIGA32\src -I..\..\GIGA32\gd32\peripherals\inc -I..\..\GIGA32\gd32\peripherals\src -I.\RTE\_Target_1 -IF:\software\mdk\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\software\mdk\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD -DDAPLINK_VERSION=242 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DINTERFACE_GD32F103 -DCPU_GD32F103CBT6 -DDAPLINK_HIC_ID=0x97969905 -DBL_TARGET_FLASH -DUSE_STDPERIPH_DRIVER -DGD32F10X_MD -DUSE_HSE_16MHZ --omf_browse=.\objects\gd32f10x_usart.crf ..\..\GIGA32\gd32\peripherals\src\gd32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_Address||, CODE, READONLY, ALIGN=1

                  USART_Address PROC
;;;311      */
;;;312    void USART_Address(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;313    {
;;;314        /* Clear the USART address and Set the USART terminal*/
;;;315        USARTx->CTLR2 &= ~USART_CTLR2_ADD;
000002  f022020f          BIC      r2,r2,#0xf
000006  8202              STRH     r2,[r0,#0x10]
;;;316        
;;;317        USARTx->CTLR2 |=USART_Address;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;318    }
00000e  4770              BX       lr
;;;319    
                          ENDP


                          AREA ||i.USART_ClearBitState||, CODE, READONLY, ALIGN=1

                  USART_ClearBitState PROC
;;;709      */
;;;710    void USART_ClearBitState(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  43c9              MVNS     r1,r1
;;;711    {
;;;712        USARTx->STR =(uint16_t)~ USART_FLAG;
000002  8001              STRH     r1,[r0,#0]
;;;713    }
000004  4770              BX       lr
;;;714    
                          ENDP


                          AREA ||i.USART_ClearIntBitState||, CODE, READONLY, ALIGN=1

                  USART_ClearIntBitState PROC
;;;807      */
;;;808    void USART_ClearIntBitState(USART_TypeDef* USARTx, uint16_t USART_INT)
000000  0a0a              LSRS     r2,r1,#8
;;;809    {
;;;810        uint16_t bitpos = 0, itmask = 0;
;;;811        
;;;812        bitpos = USART_INT >> 0x08;
;;;813        itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000002  2101              MOVS     r1,#1
000004  4091              LSLS     r1,r1,r2
;;;814        USARTx->STR = (uint16_t)~itmask;
000006  43c9              MVNS     r1,r1
000008  8001              STRH     r1,[r0,#0]
;;;815    }
00000a  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;189      */
;;;190    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitPara* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192        uint32_t temp = 0;
;;;193        
;;;194        temp = USARTx->CTLR2;
000002  8a02              LDRH     r2,[r0,#0x10]
;;;195        /* Clear CKEN, CPL, CPH, LBCP and SSM bits */
;;;196        temp &= ~(CTLR2_CLOCK_CLEAR_MASK);
;;;197        
;;;198        /* Reset hen set it usethe USART Clock, CPL, CPH, LBCP */
;;;199        temp |= (uint32_t)(USART_ClockInitStruct->USART_CKEN | USART_ClockInitStruct->USART_CPL | 
000004  884c              LDRH     r4,[r1,#2]
000006  f4226370          BIC      r3,r2,#0xf00          ;196
00000a  880a              LDRH     r2,[r1,#0]
00000c  4322              ORRS     r2,r2,r4
00000e  888c              LDRH     r4,[r1,#4]
000010  88c9              LDRH     r1,[r1,#6]
000012  430c              ORRS     r4,r4,r1
000014  4322              ORRS     r2,r2,r4
000016  431a              ORRS     r2,r2,r3
;;;200                           USART_ClockInitStruct->USART_CPH | USART_ClockInitStruct->USART_LBCP);
;;;201        /* Write to USART CTLR2 */
;;;202        USARTx->CTLR2 = (uint16_t)temp;
000018  8202              STRH     r2,[r0,#0x10]
;;;203    }
00001a  bd10              POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;209      */
;;;210    void USART_ClockStructInit(USART_ClockInitPara* USART_ClockInitParaStruct)
000000  2100              MOVS     r1,#0
;;;211    {
;;;212        /*Reset USART_ClockInitStruct members default value */
;;;213        USART_ClockInitParaStruct->USART_CKEN = USART_CKEN_RESET;
000002  8001              STRH     r1,[r0,#0]
;;;214        USART_ClockInitParaStruct->USART_CPL  = USART_CPL_LOW;
000004  8041              STRH     r1,[r0,#2]
;;;215        USART_ClockInitParaStruct->USART_CPH  = USART_CPH_1EDGE;
000006  8081              STRH     r1,[r0,#4]
;;;216        USART_ClockInitParaStruct->USART_LBCP = USART_LBCP_DISABLE;
000008  80c1              STRH     r1,[r0,#6]
;;;217    }
00000a  4770              BX       lr
;;;218    
                          ENDP


                          AREA ||i.USART_DMA_Enable||, CODE, READONLY, ALIGN=1

                  USART_DMA_Enable PROC
;;;525      */
;;;526    void USART_DMA_Enable(USART_TypeDef* USARTx, uint16_t USART_DMAEnable, TypeState NewValue)
000000  2a00              CMP      r2,#0
;;;527    {
;;;528        /* Enable or disable the DMA transfer for transmission or reception by setting the DENT and/or
;;;529        DENR bits in the USART CTLR3 register */
;;;530        if (NewValue != DISABLE)
;;;531        {
;;;532            USARTx->CTLR3 |= USART_DMAEnable;
;;;533        }
;;;534        else
;;;535        {
;;;536            USARTx->CTLR3 &= ~USART_DMAEnable;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  d001              BEQ      |L6.10|
000006  430a              ORRS     r2,r2,r1              ;532
000008  e000              B        |L6.12|
                  |L6.10|
00000a  438a              BICS     r2,r2,r1
                  |L6.12|
00000c  8282              STRH     r2,[r0,#0x14]         ;532
;;;537        }
;;;538        
;;;539    }
00000e  4770              BX       lr
;;;540    
                          ENDP


                          AREA ||i.USART_DataReceive||, CODE, READONLY, ALIGN=1

                  USART_DataReceive PROC
;;;293      */
;;;294    uint16_t USART_DataReceive(USART_TypeDef* USARTx)
000000  8880              LDRH     r0,[r0,#4]
;;;295    {
;;;296        return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;297    }
000006  4770              BX       lr
;;;298     
                          ENDP


                          AREA ||i.USART_DataSend||, CODE, READONLY, ALIGN=1

                  USART_DataSend PROC
;;;277      */
;;;278    void USART_DataSend(USART_TypeDef* USARTx,uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;279    {
;;;280        USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8081              STRH     r1,[r0,#4]
;;;281    }
000006  4770              BX       lr
;;;282       
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;59       */
;;;60     void USART_DeInit(USART_TypeDef* USARTx)
000000  4917              LDR      r1,|L9.96|
;;;61     {
000002  b510              PUSH     {r4,lr}
;;;62         if (USARTx == USART1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L9.30|
;;;63         {
;;;64             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  038c              LSLS     r4,r1,#14
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphReset_Enable
;;;65             RCC_APB2PeriphReset_Enable(RCC_APB2PERIPH_USART1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphReset_Enable
                  |L9.30|
;;;66         }
;;;67         else if (USARTx == USART2)
00001e  4911              LDR      r1,|L9.100|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L9.42|
;;;68         {
;;;69              RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  044c              LSLS     r4,r1,#17
;;;70              RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_USART2, DISABLE);
000028  e010              B        |L9.76|
                  |L9.42|
;;;71         }
;;;72         else if (USARTx == USART3)
00002a  490f              LDR      r1,|L9.104|
00002c  4288              CMP      r0,r1
00002e  d102              BNE      |L9.54|
;;;73         {
;;;74             RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_USART3, ENABLE);
000030  2101              MOVS     r1,#1
000032  048c              LSLS     r4,r1,#18
;;;75             RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_USART3, DISABLE);
000034  e00a              B        |L9.76|
                  |L9.54|
;;;76         }    
;;;77         else if (USARTx == UART4)
000036  490d              LDR      r1,|L9.108|
000038  4288              CMP      r0,r1
00003a  d102              BNE      |L9.66|
;;;78         {
;;;79              RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_UART4, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  04cc              LSLS     r4,r1,#19
;;;80              RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_UART4, DISABLE);
000040  e004              B        |L9.76|
                  |L9.66|
;;;81         }
;;;82         else
;;;83         {
;;;84             if (USARTx == UART5)
000042  490b              LDR      r1,|L9.112|
000044  4288              CMP      r0,r1
000046  d10a              BNE      |L9.94|
;;;85             {
;;;86              RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_UART5, ENABLE);
000048  2101              MOVS     r1,#1
00004a  050c              LSLS     r4,r1,#20
                  |L9.76|
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       RCC_APB1PeriphReset_Enable
;;;87              RCC_APB1PeriphReset_Enable(RCC_APB1PERIPH_UART5, DISABLE);
000052  4620              MOV      r0,r4
000054  e8bd4010          POP      {r4,lr}
000058  2100              MOVS     r1,#0
00005a  f7ffbffe          B.W      RCC_APB1PeriphReset_Enable
                  |L9.94|
;;;88             }
;;;89         }
;;;90     }
00005e  bd10              POP      {r4,pc}
;;;91     
                          ENDP

                  |L9.96|
                          DCD      0x40013800
                  |L9.100|
                          DCD      0x40004400
                  |L9.104|
                          DCD      0x40004800
                  |L9.108|
                          DCD      0x40004c00
                  |L9.112|
                          DCD      0x40005000

                          AREA ||i.USART_Enable||, CODE, READONLY, ALIGN=1

                  USART_Enable PROC
;;;231      */
;;;232    void USART_Enable(USART_TypeDef* USARTx, TypeState NewValue)
000000  2900              CMP      r1,#0
;;;233    {
;;;234        /* Enable or disable the specified USART peripheral by setting the UEN bit in the CTLR1 register */ 
;;;235        if (NewValue!= DISABLE)
;;;236        {
;;;237            USARTx->CTLR1 |= USART_CTLR1_UEN;
;;;238        }
;;;239        else
;;;240        {
;;;241            USARTx->CTLR1 &= ~((uint16_t)USART_CTLR1_UEN);
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L10.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;237
00000a  e001              B        |L10.16|
                  |L10.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L10.16|
000010  8181              STRH     r1,[r0,#0xc]          ;237
;;;242        }
;;;243    }
000012  4770              BX       lr
;;;244     
                          ENDP


                          AREA ||i.USART_GetBitState||, CODE, READONLY, ALIGN=1

                  USART_GetBitState PROC
;;;610      */
;;;611    TypeState USART_GetBitState(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  8800              LDRH     r0,[r0,#0]
;;;612    {
;;;613        if ((USARTx->STR & USART_FLAG) != (uint16_t)RESET)
000002  4008              ANDS     r0,r0,r1
000004  d000              BEQ      |L11.8|
;;;614        {
;;;615            return  SET;
000006  2001              MOVS     r0,#1
                  |L11.8|
;;;616        }
;;;617        else
;;;618        {
;;;619            return  RESET;
;;;620        }
;;;621    }
000008  4770              BX       lr
;;;622    
                          ENDP


                          AREA ||i.USART_GetIntBitState||, CODE, READONLY, ALIGN=1

                  USART_GetIntBitState PROC
;;;737      */
;;;738    TypeState USART_GetIntBitState(USART_TypeDef* USARTx, uint16_t USART_INT)
000000  b510              PUSH     {r4,lr}
;;;739    {
;;;740        uint16_t bitpos = 0, itmask = 0, usartreg = 0;
;;;741        
;;;742        /* Get the USART register index and the interrupt position */
;;;743        usartreg = (((uint8_t)USART_INT) >> 0x05);
;;;744        
;;;745        itmask = (USART_INT)&(INT_MASK);
000002  f001031f          AND      r3,r1,#0x1f
;;;746        
;;;747        itmask = (uint16_t)0x01 << itmask;
000006  2401              MOVS     r4,#1
000008  fa04f303          LSL      r3,r4,r3
00000c  f3c11242          UBFX     r2,r1,#5,#3           ;743
000010  b29b              UXTH     r3,r3
;;;748        
;;;749        if (usartreg == 0x01)
000012  2a01              CMP      r2,#1
000014  d00f              BEQ      |L12.54|
;;;750        {
;;;751            itmask &= USARTx->CTLR1;
;;;752        }
;;;753        else
;;;754        {
;;;755            if (usartreg == 0x02) 
000016  2a02              CMP      r2,#2
000018  d00f              BEQ      |L12.58|
;;;756            {
;;;757                itmask &= USARTx->CTLR2;
;;;758            }
;;;759            else 
;;;760            {
;;;761                itmask &= USARTx->CTLR3;
00001a  8a82              LDRH     r2,[r0,#0x14]
                  |L12.28|
;;;762            }
;;;763        }
;;;764        
;;;765        bitpos = USART_INT >> 0x08;
00001c  ea4f2111          LSR      r1,r1,#8
;;;766        bitpos = (uint32_t)0x01 << bitpos;
000020  fa04f401          LSL      r4,r4,r1
;;;767        bitpos &= USARTx->STR;
000024  8800              LDRH     r0,[r0,#0]
000026  421a              TST      r2,r3                 ;757
000028  b2a1              UXTH     r1,r4                 ;766
00002a  ea000001          AND      r0,r0,r1
00002e  d006              BEQ      |L12.62|
;;;768        if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
000030  b128              CBZ      r0,|L12.62|
;;;769        {
;;;770            return  SET;
000032  2001              MOVS     r0,#1
;;;771        }
;;;772        else
;;;773        {
;;;774            return  RESET;
;;;775        }
;;;776    }
000034  bd10              POP      {r4,pc}
                  |L12.54|
000036  8982              LDRH     r2,[r0,#0xc]          ;751
000038  e7f0              B        |L12.28|
                  |L12.58|
00003a  8a02              LDRH     r2,[r0,#0x10]         ;757
00003c  e7ee              B        |L12.28|
                  |L12.62|
00003e  2000              MOVS     r0,#0                 ;774
000040  bd10              POP      {r4,pc}
;;;777    
                          ENDP


                          AREA ||i.USART_GuardTime_Set||, CODE, READONLY, ALIGN=1

                  USART_GuardTime_Set PROC
;;;450      */
;;;451    void USART_GuardTime_Set(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;452    {    
;;;453        /* Set the USART guard time */
;;;454        USARTx->GTPR &= ~((uint16_t)USART_GTPR_GT);
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;455        
;;;456        USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8301              STRH     r1,[r0,#0x18]
;;;457    }
00000e  4770              BX       lr
;;;458    
                          ENDP


                          AREA ||i.USART_HalfDuplex_Enable||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplex_Enable PROC
;;;427      */
;;;428    void USART_HalfDuplex_Enable(USART_TypeDef* USARTx, TypeState NewValue)
000000  2900              CMP      r1,#0
;;;429    {
;;;430        /* By setting the HDEN bit in the CTLR3 register enable or disable the Half-duplex mode */ 
;;;431        if (NewValue  != DISABLE)
;;;432        {
;;;433            USARTx->CTLR3 |= USART_CTLR3_HDEN;
;;;434        }
;;;435        else
;;;436        {
;;;437            USARTx->CTLR3 &= ~USART_CTLR3_HDEN;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L14.12|
000006  f0410108          ORR      r1,r1,#8              ;433
00000a  e001              B        |L14.16|
                  |L14.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L14.16|
000010  8281              STRH     r1,[r0,#0x14]         ;433
;;;438        }
;;;439    }
000012  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.USART_INT_Set||, CODE, READONLY, ALIGN=1

                  USART_INT_Set PROC
;;;645      */
;;;646    void USART_INT_Set(USART_TypeDef* USARTx, uint16_t USART_INT, TypeState NewValue)
000000  f3c11342          UBFX     r3,r1,#5,#3
;;;647    {
;;;648        uint32_t  intpos=0 , usartreg=0;
;;;649        uint32_t  usartxbase = 0;
;;;650        
;;;651        usartxbase = (uint32_t)USARTx;
;;;652        
;;;653        /* Get the USART register index and the interrupt position */
;;;654        usartreg = ((uint8_t)(USART_INT) >> 0x05); 
;;;655        intpos = USART_INT & INT_MASK;
;;;656        
;;;657        /* Get the interrupt from which register: CTLR1,CTLR2 OR CTLR3 */
;;;658        if (usartreg == 0x01) 
000004  2b01              CMP      r3,#1
000006  d00a              BEQ      |L15.30|
;;;659        {
;;;660            usartxbase += 0x0C;
;;;661        }
;;;662        else if (usartreg == 0x02) 
000008  2b02              CMP      r3,#2
00000a  d00a              BEQ      |L15.34|
00000c  3014              ADDS     r0,r0,#0x14
                  |L15.14|
00000e  2301              MOVS     r3,#1                 ;648
000010  f001011f          AND      r1,r1,#0x1f           ;655
;;;663        {
;;;664            usartxbase += 0x10;
;;;665        }
;;;666        else 
;;;667        {
;;;668           usartxbase += 0x14;       
;;;669        }
;;;670        if (NewValue != DISABLE)
;;;671        {
;;;672            *(__IO uint32_t*)usartxbase  |= (((uint32_t)0x01) << intpos);
000014  408b              LSLS     r3,r3,r1
;;;673        }
;;;674        else
;;;675        {
;;;676            *(__IO uint32_t*)usartxbase &= ~(((uint32_t)0x01) << intpos);
000016  6801              LDR      r1,[r0,#0]
000018  b12a              CBZ      r2,|L15.38|
00001a  4319              ORRS     r1,r1,r3              ;672
00001c  e004              B        |L15.40|
                  |L15.30|
00001e  300c              ADDS     r0,r0,#0xc            ;672
000020  e7f5              B        |L15.14|
                  |L15.34|
000022  3010              ADDS     r0,r0,#0x10           ;660
000024  e7f3              B        |L15.14|
                  |L15.38|
000026  4399              BICS     r1,r1,r3
                  |L15.40|
000028  6001              STR      r1,[r0,#0]            ;672
;;;677        }
;;;678    }
00002a  4770              BX       lr
;;;679    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;103      */
;;;104    void USART_Init(USART_TypeDef* USARTx, USART_InitPara* USART_InitParaStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;105    {
000002  4604              MOV      r4,r0
;;;106        uint32_t divider = 0, apbclock = 0, temp = 0;
;;;107        RCC_ClocksPara RCC_ClocksState;
;;;108        
;;;109        USARTx->CTLR1 &= ~((uint32_t)USART_CTLR1_UEN);
000004  8980              LDRH     r0,[r0,#0xc]
000006  b085              SUB      sp,sp,#0x14           ;105
000008  460d              MOV      r5,r1                 ;105
00000a  f4205000          BIC      r0,r0,#0x2000
00000e  81a0              STRH     r0,[r4,#0xc]
;;;110        /* Initialize CTLR2 */ 
;;;111        temp = USARTx->CTLR2;
000010  8a20              LDRH     r0,[r4,#0x10]
;;;112        /* Reset stop bits then set it use USART_STBits */
;;;113        temp &= ~((uint32_t)USART_CTLR2_STB);
000012  f4205140          BIC      r1,r0,#0x3000
;;;114        temp |= (uint32_t)USART_InitParaStruct->USART_STBits;
000016  88e8              LDRH     r0,[r5,#6]
000018  4308              ORRS     r0,r0,r1
;;;115        
;;;116        USARTx->CTLR2 = temp;
00001a  8220              STRH     r0,[r4,#0x10]
;;;117        
;;;118        /*Initialize CTLR1*/
;;;119        temp = USARTx->CTLR1;
00001c  89a0              LDRH     r0,[r4,#0xc]
;;;120        /* Reset WL, PCEN, PM, TEN and REN bits */
;;;121        temp &= ~((uint32_t)CTLR1_CLEAR_MASK);
00001e  f241610c          MOV      r1,#0x160c
000022  4388              BICS     r0,r0,r1
;;;122        
;;;123        /* According to USART_WL,USART_Parity,USART_RxorTx to configure the CTLR1 */
;;;124        temp |= (uint32_t)USART_InitParaStruct->USART_WL | USART_InitParaStruct->USART_Parity |
000024  88a9              LDRH     r1,[r5,#4]
000026  892a              LDRH     r2,[r5,#8]
000028  4311              ORRS     r1,r1,r2
00002a  896a              LDRH     r2,[r5,#0xa]
00002c  4302              ORRS     r2,r2,r0
00002e  4311              ORRS     r1,r1,r2
;;;125        USART_InitParaStruct->USART_RxorTx;
;;;126        USARTx->CTLR1 = temp;
000030  81a1              STRH     r1,[r4,#0xc]
;;;127        
;;;128        /*Initialize CTLR3*/
;;;129        temp = USARTx->CTLR3;
000032  8aa0              LDRH     r0,[r4,#0x14]
;;;130        /* Reset CTSEN and RTSEN bits */
;;;131        temp &= ~((uint32_t)CTLR3_CLEAR_MASK);
000034  f4207140          BIC      r1,r0,#0x300
;;;132        
;;;133        /* According to USART_HardwareFlowControl to configure the CTLR3 */
;;;134        temp |= USART_InitParaStruct->USART_HardwareFlowControl;
000038  89a8              LDRH     r0,[r5,#0xc]
00003a  4308              ORRS     r0,r0,r1
;;;135        USARTx->CTLR3 = temp;
00003c  82a0              STRH     r0,[r4,#0x14]
;;;136        
;;;137        /*Initialize USART BRR*/
;;;138        RCC_GetClocksFreq(&RCC_ClocksState);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       RCC_GetClocksFreq
;;;139        
;;;140        if (USARTx == USART1)
000044  4809              LDR      r0,|L16.108|
000046  4284              CMP      r4,r0
000048  d101              BNE      |L16.78|
;;;141        {
;;;142            apbclock = RCC_ClocksState.APB2_Frequency;
00004a  9903              LDR      r1,[sp,#0xc]
00004c  e000              B        |L16.80|
                  |L16.78|
;;;143        }
;;;144        else
;;;145        {
;;;146            apbclock = RCC_ClocksState.APB1_Frequency;
00004e  9902              LDR      r1,[sp,#8]
                  |L16.80|
;;;147        }
;;;148        
;;;149        /* Get integer of baud-rate divide and raction of baud-rate divider */
;;;150        divider = (uint32_t)((apbclock) / ((USART_InitParaStruct->USART_BRR)));
000050  682a              LDR      r2,[r5,#0]
000052  fbb1f0f2          UDIV     r0,r1,r2
;;;151        temp    = (uint32_t)((apbclock) % ((USART_InitParaStruct->USART_BRR)));
000056  fbb1f3f2          UDIV     r3,r1,r2
00005a  fb021113          MLS      r1,r2,r3,r1
;;;152       
;;;153        /* Round the divider : if fractional part i greater than 0.5 increment divider */
;;;154        if (temp >=  (USART_InitParaStruct->USART_BRR) / 2)
00005e  ebb10f52          CMP      r1,r2,LSR #1
000062  d300              BCC      |L16.102|
000064  1c40              ADDS     r0,r0,#1
                  |L16.102|
;;;155        {
;;;156            divider++;
;;;157        } 
;;;158         
;;;159        USARTx->BRR = (uint16_t)divider;
000066  8120              STRH     r0,[r4,#8]
;;;160    }
000068  b005              ADD      sp,sp,#0x14
00006a  bd30              POP      {r4,r5,pc}
;;;161    
                          ENDP

                  |L16.108|
                          DCD      0x40013800

                          AREA ||i.USART_IrDA_Enable||, CODE, READONLY, ALIGN=1

                  USART_IrDA_Enable PROC
;;;574      */
;;;575    void USART_IrDA_Enable(USART_TypeDef* USARTx,TypeState NewValue)
000000  2900              CMP      r1,#0
;;;576    {
;;;577        /* By setting the IREN bit in the CTLR3 register enable or disable the USART's IrDA interface */
;;;578        if (NewValue != DISABLE)
;;;579        {
;;;580            USARTx->CTLR3 |= USART_CTLR3_IREN;
;;;581        }
;;;582        else
;;;583        {
;;;584            USARTx->CTLR3 &= ~((uint16_t)USART_CTLR3_IREN);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L17.12|
000006  f0410102          ORR      r1,r1,#2              ;580
00000a  e001              B        |L17.16|
                  |L17.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L17.16|
000010  8281              STRH     r1,[r0,#0x14]         ;580
;;;585        }
;;;586    }
000012  4770              BX       lr
;;;587    
                          ENDP


                          AREA ||i.USART_IrDA_Set||, CODE, READONLY, ALIGN=1

                  USART_IrDA_Set PROC
;;;555      */
;;;556    void USART_IrDA_Set(USART_TypeDef* USARTx,uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;557    {
;;;558        USARTx->CTLR3 &= ~((uint16_t)USART_CTLR3_IRLP);
000002  f0220204          BIC      r2,r2,#4
000006  8282              STRH     r2,[r0,#0x14]
;;;559        USARTx->CTLR3 |= USART_IrDAMode;
000008  8a82              LDRH     r2,[r0,#0x14]
00000a  430a              ORRS     r2,r2,r1
00000c  8282              STRH     r2,[r0,#0x14]
;;;560    }
00000e  4770              BX       lr
;;;561    
                          ENDP


                          AREA ||i.USART_LIN_Enable||, CODE, READONLY, ALIGN=1

                  USART_LIN_Enable PROC
;;;401      */
;;;402    void USART_LIN_Enable(USART_TypeDef* USARTx,TypeState NewValue)
000000  2900              CMP      r1,#0
;;;403    {
;;;404        /* By setting the LINEN bit in the CTLR2 register enable or disable the USART's LIN mode */
;;;405        if (NewValue != DISABLE)
;;;406        {
;;;407            USARTx->CTLR2 |= USART_CTLR2_LMEN;
;;;408        }
;;;409        else
;;;410        {
;;;411            USARTx->CTLR2 &=~((uint16_t)USART_CTLR2_LMEN);
000002  8a01              LDRH     r1,[r0,#0x10]
000004  d002              BEQ      |L19.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;407
00000a  e001              B        |L19.16|
                  |L19.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L19.16|
000010  8201              STRH     r1,[r0,#0x10]         ;407
;;;412        }
;;;413    }
000012  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.USART_MuteModeWakeUp_Set||, CODE, READONLY, ALIGN=1

                  USART_MuteModeWakeUp_Set PROC
;;;360      */
;;;361    void USART_MuteModeWakeUp_Set(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;362    {
;;;363        USARTx->CTLR1 &= ~((uint16_t)USART_CTLR1_WM);
000002  f4226200          BIC      r2,r2,#0x800
000006  8182              STRH     r2,[r0,#0xc]
;;;364        USARTx->CTLR1 |= USART_WakeUp;
000008  8982              LDRH     r2,[r0,#0xc]
00000a  430a              ORRS     r2,r2,r1
00000c  8182              STRH     r2,[r0,#0xc]
;;;365    }
00000e  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.USART_MuteMode_Enable||, CODE, READONLY, ALIGN=1

                  USART_MuteMode_Enable PROC
;;;332      */
;;;333    void USART_MuteMode_Enable(USART_TypeDef* USARTx, TypeState NewValue)
000000  2900              CMP      r1,#0
;;;334    {
;;;335        /* By setting the MEN bit in the CTLR1 register enable or disable the USART's mute mode*/
;;;336        if (NewValue != DISABLE)
;;;337        {
;;;338            USARTx->CTLR1 |= USART_CTLR1_RWU;
;;;339        }
;;;340        else
;;;341        {
;;;342            USARTx->CTLR1 &=~USART_CTLR1_RWU;
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L21.12|
000006  f0410102          ORR      r1,r1,#2              ;338
00000a  e001              B        |L21.16|
                  |L21.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L21.16|
000010  8181              STRH     r1,[r0,#0xc]          ;338
;;;343        }
;;;344    }
000012  4770              BX       lr
;;;345    
                          ENDP


                          AREA ||i.USART_ParaInit||, CODE, READONLY, ALIGN=1

                  USART_ParaInit PROC
;;;166      */
;;;167    void USART_ParaInit(USART_InitPara* USART_InitParaStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;168    {
;;;169        /* USART_InitStruct members default value */
;;;170        USART_InitParaStruct->USART_BRR = 9600;
;;;171        USART_InitParaStruct->USART_WL   =USART_WL_8B;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;172        USART_InitParaStruct->USART_STBits =USART_STBITS_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;173        USART_InitParaStruct->USART_Parity =USART_PARITY_RESET;
00000c  8101              STRH     r1,[r0,#8]
;;;174        USART_InitParaStruct->USART_RxorTx =USART_RXORTX_RX | USART_RXORTX_TX;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;175        USART_InitParaStruct->USART_HardwareFlowControl =USART_HARDWAREFLOWCONTROL_NONE;
000012  8181              STRH     r1,[r0,#0xc]
;;;176    }   
000014  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;827      */
;;;828    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;829    {
;;;830      
;;;831        /* Send break command */
;;;832        USARTx->CTLR1 |= USART_CTLR1_SBKCMD;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;833    }
000008  4770              BX       lr
;;;834    
                          ENDP


                          AREA ||i.USART_SetLINBDLength||, CODE, READONLY, ALIGN=1

                  USART_SetLINBDLength PROC
;;;382      */
;;;383    void USART_SetLINBDLength(USART_TypeDef* USARTx,uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;384    {
;;;385        USARTx->CTLR2 &= ~((uint16_t)USART_CTLR2_LBDL);
000002  f0220220          BIC      r2,r2,#0x20
000006  8202              STRH     r2,[r0,#0x10]
;;;386        USARTx->CTLR2 |= USART_LINBreakDetectLength;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;387    }
00000e  4770              BX       lr
;;;388    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;257      */
;;;258    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;259    { 
;;;260        /* Clear and set the USART prescaler */
;;;261        USARTx->GTPR &= ~((uint16_t)USART_GTPR_PSC);
000002  f02202ff          BIC      r2,r2,#0xff
000006  8302              STRH     r2,[r0,#0x18]
;;;262        
;;;263        USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;264    }
00000e  4770              BX       lr
;;;265    
                          ENDP


                          AREA ||i.USART_SmartCardNACK_Enable||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACK_Enable PROC
;;;495      */
;;;496    void USART_SmartCardNACK_Enable(USART_TypeDef* USARTx,TypeState NewValue)
000000  2900              CMP      r1,#0
;;;497    {
;;;498        /* By setting the NACK bit in the CTLR3 register Enable or disable NACK transmission */
;;;499        if (NewValue != DISABLE)
;;;500        {
;;;501            USARTx->CTLR3 |= USART_CTLR3_NACK;
;;;502        }
;;;503        else
;;;504        {
;;;505            USARTx->CTLR3 &= ~((uint32_t)USART_CTLR3_NACK);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L26.12|
000006  f0410110          ORR      r1,r1,#0x10           ;501
00000a  e001              B        |L26.16|
                  |L26.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L26.16|
000010  8281              STRH     r1,[r0,#0x14]         ;501
;;;506        }
;;;507    }
000012  4770              BX       lr
;;;508    
                          ENDP


                          AREA ||i.USART_SmartCard_Enable||, CODE, READONLY, ALIGN=1

                  USART_SmartCard_Enable PROC
;;;469      */
;;;470    void USART_SmartCard_Enable(USART_TypeDef* USARTx,TypeState NewValue)
000000  2900              CMP      r1,#0
;;;471    {
;;;472        /* By setting the SCEN bit in the CTLR3 register enable or disable the USART's Smart Card mode */
;;;473        if (NewValue != DISABLE)
;;;474        {
;;;475            USARTx->CTLR3 |= USART_CTLR3_SCEN;
;;;476        }
;;;477        else
;;;478        {
;;;479            USARTx->CTLR3 &= ~((uint16_t)USART_CTLR3_SCEN);
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L27.12|
000006  f0410120          ORR      r1,r1,#0x20           ;475
00000a  e001              B        |L27.16|
                  |L27.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L27.16|
000010  8281              STRH     r1,[r0,#0x14]         ;475
;;;480        }
;;;481    }
000012  4770              BX       lr
;;;482    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\GIGA32\\gd32\\peripherals\\src\\gd32f10x_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_gd32f10x_usart_c_9565154b____REV16|
#line 129 "..\\..\\cmsis-core\\core_cmInstr.h"
|__asm___16_gd32f10x_usart_c_9565154b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_gd32f10x_usart_c_9565154b____REVSH|
#line 144
|__asm___16_gd32f10x_usart_c_9565154b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
