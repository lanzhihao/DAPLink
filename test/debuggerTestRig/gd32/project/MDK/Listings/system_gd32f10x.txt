; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\system_gd32f10x.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\system_gd32f10x.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\startup -I..\..\cmsis-core -I..\src -I..\..\GIGA32\inc -I..\..\GIGA32\src -I..\..\GIGA32\gd32\peripherals\inc -I..\..\GIGA32\gd32\peripherals\src -I.\RTE\_Target_1 -IF:\software\mdk\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\software\mdk\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD -DDAPLINK_VERSION=242 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DINTERFACE_GD32F103 -DCPU_GD32F103CBT6 -DDAPLINK_HIC_ID=0x97969905 -DBL_TARGET_FLASH -DUSE_STDPERIPH_DRIVER -DGD32F10X_MD -DUSE_HSE_16MHZ --omf_browse=.\objects\system_gd32f10x.crf ..\..\GIGA32\gd32\system_gd32f10x.c]
                          THUMB

                          AREA ||i.SetSysClockTo96||, CODE, READONLY, ALIGN=2

                  SetSysClockTo96 PROC
;;;916      */
;;;917    static void SetSysClockTo96(void)
000000  b50c              PUSH     {r2,r3,lr}
;;;918    {
;;;919      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2300              MOVS     r3,#0
;;;920      
;;;921      /* CK_SYS, AHB, APB2 and APB1 configuration ---------------------------*/    
;;;922      /* Enable HSE */    
;;;923      RCC->GCCR |= ((uint32_t)RCC_GCCR_HSEEN);
000004  4820              LDR      r0,|L1.136|
000006  9300              STR      r3,[sp,#0]            ;919
000008  9301              STR      r3,[sp,#4]
00000a  6801              LDR      r1,[r0,#0]
00000c  f4413180          ORR      r1,r1,#0x10000
000010  6001              STR      r1,[r0,#0]
;;;924     
;;;925      /* Wait till HSE is ready and if Time out is reached exit */
;;;926      do
;;;927      {
;;;928        HSEStatus = RCC->GCCR & RCC_GCCR_HSESTB;
;;;929        StartUpCounter++;  
;;;930      } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
000012  f64f71ff          MOV      r1,#0xffff
                  |L1.22|
000016  6802              LDR      r2,[r0,#0]            ;928
000018  f4023200          AND      r2,r2,#0x20000        ;928
00001c  9201              STR      r2,[sp,#4]            ;929
00001e  9a00              LDR      r2,[sp,#0]            ;929
000020  1c52              ADDS     r2,r2,#1              ;929
000022  9200              STR      r2,[sp,#0]
000024  9a01              LDR      r2,[sp,#4]
000026  b912              CBNZ     r2,|L1.46|
000028  9a00              LDR      r2,[sp,#0]
00002a  428a              CMP      r2,r1
00002c  d1f3              BNE      |L1.22|
                  |L1.46|
;;;931    
;;;932      if ((RCC->GCCR & RCC_GCCR_HSESTB) != RESET)
00002e  6801              LDR      r1,[r0,#0]
000030  0389              LSLS     r1,r1,#14
000032  d526              BPL      |L1.130|
;;;933      {
;;;934        HSEStatus = (uint32_t)0x01;
000034  2101              MOVS     r1,#1
;;;935      }
;;;936      else
;;;937      {
;;;938        HSEStatus = (uint32_t)0x00;
;;;939      }  
;;;940    
;;;941      if (HSEStatus == (uint32_t)0x01)
;;;942      {
;;;943        /* AHB = CK_SYS not divided */
;;;944        RCC->GCFGR |= (uint32_t)RCC_GCFGR_AHBPS_DIV1;
000036  9101              STR      r1,[sp,#4]
000038  6841              LDR      r1,[r0,#4]
00003a  6041              STR      r1,[r0,#4]
;;;945          
;;;946        /* APB2 = AHB not divided */
;;;947        RCC->GCFGR |= (uint32_t)RCC_GCFGR_APB2PS_DIV1;
00003c  6841              LDR      r1,[r0,#4]
00003e  6041              STR      r1,[r0,#4]
;;;948        
;;;949        /* APB1 = AHB is divided 2 */
;;;950        RCC->GCFGR |= (uint32_t)RCC_GCFGR_APB1PS_DIV2;
000040  6841              LDR      r1,[r0,#4]
000042  f4416180          ORR      r1,r1,#0x400
000046  6041              STR      r1,[r0,#4]
;;;951    
;;;952    #ifdef GD32F10X_CL
;;;953        /* Configure PLLs ------------------------------------------------------*/
;;;954    
;;;955        /* PLL configuration: PLLCLK = PREDIV1 * 12 = 96 MHz */ 
;;;956        RCC->GCFGR &= (uint32_t)~(RCC_GCFGR_PLLPREDV | RCC_GCFGR_PLLSEL | RCC_GCFGR_PLLMF);
;;;957        RCC->GCFGR |= (uint32_t)(RCC_GCFGR_PLLSEL_PREDIV1 | RCC_GCFGR_PLLMF12); 
;;;958    
;;;959        /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;960        /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;961            
;;;962        RCC->GCFGR2 &= (uint32_t)~(RCC_GCFGR2_PREDV2 | RCC_GCFGR2_PLL2MF |
;;;963                                  RCC_GCFGR2_PREDV1 | RCC_GCFGR2_PREDV1SEL);
;;;964        RCC->GCFGR2 |= (uint32_t)( RCC_GCFGR2_PREDV2_DIV5 | RCC_GCFGR2_PLL2MF8 |
;;;965                                 RCC_GCFGR2_PREDV1SEL_PLL2 | RCC_GCFGR2_PREDV1_DIV5);
;;;966      
;;;967        /* Enable PLL2 */
;;;968        RCC->GCCR |= RCC_GCCR_PLL2EN;
;;;969        /* Wait till PLL2 is ready */
;;;970        while((RCC->GCCR & RCC_GCCR_PLL2STB) == 0)
;;;971        {
;;;972        }
;;;973    
;;;974    #else     
;;;975    
;;;976    #ifdef USE_HSE_16MHZ
;;;977        /* PLL configuration: PLLCLK = HSE/2 * 12 = 96 MHz */
;;;978        RCC->GCFGR &= (uint32_t)((uint32_t)~(RCC_GCFGR_PLLSEL | RCC_GCFGR_PLLPREDV | RCC_GCFGR_PLLMF));
000048  6841              LDR      r1,[r0,#4]
00004a  4a10              LDR      r2,|L1.140|
00004c  4011              ANDS     r1,r1,r2
00004e  6041              STR      r1,[r0,#4]
;;;979        RCC->GCFGR |= (uint32_t)( RCC_GCFGR_PLLPREDV_HSE_DIV2 | RCC_GCFGR_PLLSEL_HSE | RCC_GCFGR_PLLMF12);
000050  6841              LDR      r1,[r0,#4]
000052  f441112c          ORR      r1,r1,#0x2b0000
000056  6041              STR      r1,[r0,#4]
;;;980    #else
;;;981        /* PLL configuration: PLLCLK = HSE * 12 = 96 MHz */
;;;982        RCC->GCFGR &= (uint32_t)((uint32_t)~(RCC_GCFGR_PLLSEL | RCC_GCFGR_PLLPREDV | RCC_GCFGR_PLLMF));
;;;983        RCC->GCFGR |= (uint32_t)( RCC_GCFGR_PLLPREDV_HSE | RCC_GCFGR_PLLSEL_HSE | RCC_GCFGR_PLLMF12);    
;;;984    #endif
;;;985        
;;;986    #endif /* GD32F10X_CL */
;;;987    
;;;988        /* Enable PLL */
;;;989        RCC->GCCR |= RCC_GCCR_PLLEN;
000058  6801              LDR      r1,[r0,#0]
00005a  f0417180          ORR      r1,r1,#0x1000000
00005e  6001              STR      r1,[r0,#0]
                  |L1.96|
;;;990    
;;;991        /* Wait till PLL is ready */
;;;992        while((RCC->GCCR & RCC_GCCR_PLLSTB) == 0)
000060  6801              LDR      r1,[r0,#0]
000062  0189              LSLS     r1,r1,#6
000064  d5fc              BPL      |L1.96|
;;;993        {
;;;994        }
;;;995    
;;;996        /* Select PLL as system clock source */
;;;997        RCC->GCFGR &= (uint32_t)((uint32_t)~(RCC_GCFGR_SCS));
000066  6841              LDR      r1,[r0,#4]
000068  f0210103          BIC      r1,r1,#3
00006c  6041              STR      r1,[r0,#4]
;;;998        RCC->GCFGR |= (uint32_t)RCC_GCFGR_SCS_PLL;    
00006e  6841              LDR      r1,[r0,#4]
000070  f0410102          ORR      r1,r1,#2
000074  6041              STR      r1,[r0,#4]
                  |L1.118|
;;;999    
;;;1000       /* Wait till PLL is used as system clock source */
;;;1001       while ((RCC->GCFGR & (uint32_t)RCC_GCFGR_SCSS) != (uint32_t)0x08)
000076  6841              LDR      r1,[r0,#4]
000078  f3c10181          UBFX     r1,r1,#2,#2
00007c  2902              CMP      r1,#2
00007e  d1fa              BNE      |L1.118|
;;;1002       {
;;;1003       }
;;;1004     }
;;;1005     else
;;;1006     { 
;;;1007     } 
;;;1008   }
000080  bd0c              POP      {r2,r3,pc}
                  |L1.130|
000082  9301              STR      r3,[sp,#4]            ;938
000084  bd0c              POP      {r2,r3,pc}
;;;1009   
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40021000
                  |L1.140|
                          DCD      0xf7c0ffff

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;233      */
;;;234    void SystemCoreClockUpdate (void)
000000  4a1a              LDR      r2,|L2.108|
;;;235    {
000002  b510              PUSH     {r4,lr}
;;;236        uint32_t temp = 0, pllmf = 0, pllmf4=0,pllselect = 0, presc = 0;
;;;237    
;;;238    #ifdef  GD32F10X_CL
;;;239        uint32_t prediv1select = 0, prediv1factor = 0, prediv2factor = 0, pll2mf = 0;
;;;240    #endif /* GD32F10X_CL */
;;;241        
;;;242        /* Get CK_SYS source -------------------------------------------------------*/
;;;243        temp = RCC->GCFGR & RCC_GCFGR_SCSS;
000004  6850              LDR      r0,[r2,#4]
;;;244      
;;;245        switch (temp)
;;;246        {
;;;247            case 0x00:  /* HSI used as CK_SYS */
;;;248            SystemCoreClock = HSI_VALUE;
000006  4b1a              LDR      r3,|L2.112|
000008  f010010c          ANDS     r1,r0,#0xc            ;243
00000c  4819              LDR      r0,|L2.116|
00000e  d003              BEQ      |L2.24|
000010  2904              CMP      r1,#4                 ;245
000012  d003              BEQ      |L2.28|
000014  2908              CMP      r1,#8                 ;245
000016  d003              BEQ      |L2.32|
                  |L2.24|
;;;249            break;
000018  6003              STR      r3,[r0,#0]  ; SystemCoreClock
00001a  e01b              B        |L2.84|
                  |L2.28|
;;;250            case 0x04:  /* HSE used as CK_SYS */
;;;251            SystemCoreClock = HSE_VALUE;
00001c  4916              LDR      r1,|L2.120|
;;;252            break;
00001e  e018              B        |L2.82|
                  |L2.32|
;;;253            case 0x08:  /* PLL used as CK_SYS */
;;;254        #ifdef  GD32F10X_CL
;;;255            /* Get PLL clock source and multiplication factor ----------------------*/
;;;256            /* Get PLLMF[3:0] */
;;;257            pllmf = RCC->GCFGR & SYS_RCC_GCFGR_PLLMF_3_0;
;;;258            /* Get PLLMF[4] */
;;;259            pllmf4 = RCC->GCFGR & RCC_GCFGR_PLLMF_4;
;;;260    
;;;261            pllmf4 = (( pllmf4 >> 29)*15);
;;;262    
;;;263            pllmf = ( pllmf >> 18) + pllmf4;
;;;264            if (pllmf != 0x0D)
;;;265            {
;;;266                pllmf += 2;
;;;267            }
;;;268            else
;;;269            { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;270                pllmf = 13 / 2; 
;;;271            }
;;;272                    
;;;273            pllselect = RCC->GCFGR & RCC_GCFGR_PLLSEL;
;;;274            if (pllselect == 0x00)
;;;275            {
;;;276                /* HSI clock divided by 2 selected as PLL clock source */
;;;277                SystemCoreClock = (HSI_VALUE >>SYS_HSI_CLOCK_DIVIDED_2) * pllmf;
;;;278            }
;;;279            else
;;;280            {
;;;281                /* PREDIV1 selected as PLL clock entry */
;;;282                
;;;283                /* Get PREDIV1 clock source and division factor */
;;;284                prediv1select = RCC->GCFGR2 & RCC_GCFGR2_PREDV1SEL;
;;;285                prediv1factor = (RCC->GCFGR2 & RCC_GCFGR2_PREDV1) + 1;
;;;286                
;;;287                if (prediv1select == 0)
;;;288                {   /* HSE clock selected as PREDIV1 clock entry */
;;;289                    SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmf;          
;;;290                }
;;;291                else
;;;292                {   /* PLL2 clock selected as PREDIV1 clock entry */
;;;293                    /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;294                    prediv2factor = ((RCC->GCFGR2 & RCC_GCFGR2_PREDV2) >> 4) + 1;
;;;295                    pll2mf = ((RCC->GCFGR2 & RCC_GCFGR2_PLL2MF) >> 8);
;;;296                    if(pll2mf != 15)
;;;297                    {
;;;298                        pll2mf += 2;
;;;299                    }
;;;300                    else
;;;301                    {
;;;302                        pll2mf += 5;
;;;303                    }
;;;304                    SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mf) / prediv1factor) * pllmf;                         
;;;305                }
;;;306            }
;;;307        #else
;;;308            /* Get PLL clock source and multiplication factor ----------------------*/
;;;309            /* Get PLLMF[3:0] */
;;;310            pllmf = RCC->GCFGR & SYS_RCC_GCFGR_PLLMF_3_0;
000020  6851              LDR      r1,[r2,#4]
000022  f4011370          AND      r3,r1,#0x3c0000
;;;311            /* Get PLLMF[4] */
;;;312            pllmf4 = RCC->GCFGR & RCC_GCFGR_PLLMF_4;
000026  6851              LDR      r1,[r2,#4]
;;;313    
;;;314            pllmf4 = (( pllmf4 >> 27)*15);
;;;315            pllmf = ( pllmf >> 18) + pllmf4+ 2;
;;;316    
;;;317                    
;;;318            pllselect = RCC->GCFGR & RCC_GCFGR_PLLSEL;
;;;319            if (pllselect == 0x00)
;;;320            {
;;;321                /* HSI clock divided by 2 selected as PLL clock source */
;;;322                SystemCoreClock = (HSI_VALUE >>SYS_HSI_CLOCK_DIVIDED_2) * pllmf;
;;;323            }
;;;324            else
;;;325            {
;;;326                if((RCC->GCFGR & RCC_GCFGR_PLLPREDV) != (uint32_t)RESET )
;;;327                {
;;;328                    /* HSE clock divided by 2 */
;;;329                    SystemCoreClock = (HSE_VALUE >> 1) * pllmf;
;;;330                }
;;;331                else
;;;332                {
;;;333                    SystemCoreClock = HSE_VALUE * pllmf;
;;;334                }
;;;335            }
;;;336        #endif
;;;337            break;
;;;338            default: /* HSI used as system clock */
;;;339            SystemCoreClock = HSI_VALUE;
;;;340            break;
;;;341        }
;;;342    
;;;343        /* Get AHB prescaler */
;;;344        temp = RCC->GCFGR & RCC_GCFGR_AHBPS;
;;;345        temp = temp >> 4;
;;;346        presc = AHBPrescTableList[temp]; 
;;;347        /* Get AHB clock frequency */
;;;348        SystemCoreClock = SystemCoreClock >> presc;
;;;349    }
000028  2401              MOVS     r4,#1
00002a  ea0461d1          AND      r1,r4,r1,LSR #27
00002e  ebc11101          RSB      r1,r1,r1,LSL #4       ;314
000032  eb014193          ADD      r1,r1,r3,LSR #18      ;315
000036  6853              LDR      r3,[r2,#4]            ;318
000038  1c89              ADDS     r1,r1,#2              ;318
00003a  f4133f80          TST      r3,#0x10000           ;318
00003e  d004              BEQ      |L2.74|
000040  6853              LDR      r3,[r2,#4]            ;326
000042  039b              LSLS     r3,r3,#14             ;326
000044  d503              BPL      |L2.78|
000046  4b0a              LDR      r3,|L2.112|
000048  e002              B        |L2.80|
                  |L2.74|
00004a  4b0c              LDR      r3,|L2.124|
00004c  e000              B        |L2.80|
                  |L2.78|
00004e  4b0a              LDR      r3,|L2.120|
                  |L2.80|
000050  4359              MULS     r1,r3,r1              ;329
                  |L2.82|
000052  6001              STR      r1,[r0,#0]            ;329  ; SystemCoreClock
                  |L2.84|
000054  6851              LDR      r1,[r2,#4]            ;344
000056  220f              MOVS     r2,#0xf
000058  ea021111          AND      r1,r2,r1,LSR #4
00005c  4a05              LDR      r2,|L2.116|
00005e  1d12              ADDS     r2,r2,#4              ;346
000060  5c51              LDRB     r1,[r2,r1]            ;346
000062  6802              LDR      r2,[r0,#0]            ;348  ; SystemCoreClock
000064  40ca              LSRS     r2,r2,r1              ;348
000066  6002              STR      r2,[r0,#0]            ;348  ; SystemCoreClock
000068  bd10              POP      {r4,pc}
;;;350    
                          ENDP

00006a  0000              DCW      0x0000
                  |L2.108|
                          DCD      0x40021000
                  |L2.112|
                          DCD      0x007a1200
                  |L2.116|
                          DCD      ||.data||
                  |L2.120|
                          DCD      0x00f42400
                  |L2.124|
                          DCD      0x003d0900

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;181    
;;;182    void SystemInit (void)
000000  480c              LDR      r0,|L3.52|
;;;183    {
;;;184        /* Set RCC GCCR_HSIEN mask */
;;;185        RCC->GCCR |= SYS_GCCR_HSIEN_SET;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;186        
;;;187        /* Reset SCS[1:0], AHBPS[3:0], APB1PS[2:0],APB2PS[2:0], ADCPS[2:0],CKOTUSEL[2:0] bits */
;;;188    #ifdef GD32F10X_CL
;;;189        RCC->GCFGR &= SYS_GCFGR_RESET_CL;
;;;190    #else
;;;191        RCC->GCFGR &= SYS_GCFGR_RESET;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0a              LDR      r2,|L3.56|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;192    #endif /* GD32F10X_CL */   
;;;193      
;;;194        /* Reset HSEEN, CKMEN and PLLEN bits */
;;;195        RCC->GCCR &= SYS_GCCR_HSEEN_CKMEN_PLLEN_RESET;
000012  6801              LDR      r1,[r0,#0]
000014  4a09              LDR      r2,|L3.60|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;196    
;;;197        /* Reset HSEBPS bit */
;;;198        RCC->GCCR &= SYS_GCCR_HSEBPS_RESET;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;199    
;;;200        /* Reset PLLSEL, PLLPREDV and PLLMF[4:0] USBPS/OTGPS bits */
;;;201    #ifdef GD32F10X_CL
;;;202        RCC->GCFGR &= SYS_GCFGR_PLLSEL_PLLPREDV_PLLMF_USBPS_RESET_CL;
;;;203    #else
;;;204        RCC->GCFGR &= SYS_GCFGR_PLLSEL_PLLPREDV_PLLMF_USBPS_RESET;
000022  6841              LDR      r1,[r0,#4]
000024  4a06              LDR      r2,|L3.64|
000026  4011              ANDS     r1,r1,r2
000028  6041              STR      r1,[r0,#4]
;;;205    #endif /* GD32F10X_CL */   
;;;206        
;;;207    #ifdef GD32F10X_CL
;;;208        /* Reset PLL2EN and PLL3EN bits */
;;;209        RCC->GCCR &= SYS_GCCR_PLL2EN_PLL3EN_RESET;
;;;210    
;;;211        /* Reset GCFGR2 register */
;;;212        RCC->GCFGR2 =SYS_GCFGR2_RESET ;
;;;213    
;;;214        /* Disable all interrupts and clear flag bits */
;;;215        RCC->GCIR = SYS_GCIR_INT_FLAG_RESET_CL;
;;;216    #else
;;;217        /* Disable all interrupts and clear flag bits */
;;;218        RCC->GCIR = SYS_GCIR_INT_FLAG_RESET;
00002a  f44f011f          MOV      r1,#0x9f0000
00002e  6081              STR      r1,[r0,#8]
000030  f7ffbffe          B.W      SetSysClockTo96
;;;219    #endif /* GD32F10X_CL */   
;;;220    
;;;221      /* Configure the System clock frequency, AHB, APB2 and APB1 prescalers */
;;;222      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;223      SetSysClock();
;;;224    
;;;225    }
;;;226    
                          ENDP

                  |L3.52|
                          DCD      0x40021000
                  |L3.56|
                          DCD      0xe8ff0000
                  |L3.60|
                          DCD      0xfef6ffff
                  |L3.64|
                          DCD      0xf700ffff

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x05b8d800
                  AHBPrescTableList
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\GIGA32\\gd32\\system_gd32f10x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_system_gd32f10x_c_5d646a67____REV16|
#line 129 "..\\..\\cmsis-core\\core_cmInstr.h"
|__asm___17_system_gd32f10x_c_5d646a67____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_system_gd32f10x_c_5d646a67____REVSH|
#line 144
|__asm___17_system_gd32f10x_c_5d646a67____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
