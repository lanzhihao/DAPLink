; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\startup -I..\..\cmsis-core -I..\src -I..\..\GIGA32\inc -I..\..\GIGA32\src -I..\..\GIGA32\gd32\peripherals\inc -I..\..\GIGA32\gd32\peripherals\src -I.\RTE\_Target_1 -IF:\software\mdk\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\software\mdk\ARM\CMSIS\Include -D__UVISION_VERSION=524 -DSTM32F10X_MD -DDAPLINK_VERSION=242 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DINTERFACE_GD32F103 -DCPU_GD32F103CBT6 -DDAPLINK_HIC_ID=0x97969905 -DBL_TARGET_FLASH -DUSE_STDPERIPH_DRIVER -DGD32F10X_MD -DUSE_HSE_16MHZ --omf_browse=.\objects\uart.crf ..\src\uart.c]
                          THUMB

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;338    
;;;339    void USARTx_IRQn_Handler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;340    {
;;;341        uint8_t  dat;
;;;342        uint32_t cnt;
;;;343    
;;;344        if(USART_GetIntBitState(USARTx_BASE, USART_INT_ERIE) != RESET){
000004  4e2e              LDR      r6,|L1.192|
000006  2160              MOVS     r1,#0x60
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       USART_GetIntBitState
00000e  b120              CBZ      r0,|L1.26|
;;;345            USART_ClearIntBitState(USARTx_BASE, USART_INT_ERIE|USART_INT_TBE|USART_INT_RBNE);
000010  f2407167          MOV      r1,#0x767
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       USART_ClearIntBitState
                  |L1.26|
;;;346        }
;;;347    
;;;348        if(USART_GetIntBitState(USARTx_BASE, USART_INT_RBNE) != RESET) {
00001a  f2405425          MOV      r4,#0x525
00001e  4621              MOV      r1,r4
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       USART_GetIntBitState
;;;349            USART_ClearIntBitState(USARTx_BASE, USART_INT_RBNE);
;;;350            cnt = write_available(&rx_buffer);
;;;351            dat = USART_DataReceive(USARTx_BASE);
;;;352            if(cnt) {
;;;353                rx_buffer.data[rx_buffer.head++] = dat;
;;;354                if(rx_buffer.head >= BUFFER_SIZE)
000026  f44f7700          MOV      r7,#0x200
00002a  2500              MOVS     r5,#0
00002c  b1d0              CBZ      r0,|L1.100|
00002e  4621              MOV      r1,r4                 ;349
000030  4630              MOV      r0,r6                 ;349
000032  f7fffffe          BL       USART_ClearIntBitState
000036  4823              LDR      r0,|L1.196|
000038  f7fffffe          BL       write_available
00003c  4604              MOV      r4,r0                 ;350
00003e  4630              MOV      r0,r6                 ;351
000040  f7fffffe          BL       USART_DataReceive
000044  b2c2              UXTB     r2,r0                 ;351
000046  b16c              CBZ      r4,|L1.100|
000048  491e              LDR      r1,|L1.196|
00004a  f8d10200          LDR      r0,[r1,#0x200]        ;353  ; rx_buffer
00004e  180b              ADDS     r3,r1,r0              ;353
000050  1c40              ADDS     r0,r0,#1              ;353
000052  f8c10200          STR      r0,[r1,#0x200]        ;353  ; rx_buffer
000056  701a              STRB     r2,[r3,#0]            ;353
000058  f8d10200          LDR      r0,[r1,#0x200]  ; rx_buffer
00005c  42b8              CMP      r0,r7
00005e  d301              BCC      |L1.100|
;;;355                    rx_buffer.head = 0;
000060  f8c15200          STR      r5,[r1,#0x200]  ; rx_buffer
                  |L1.100|
;;;356    
;;;357                if(cnt <= 2) {
;;;358                    // for flow control, need to set RTS = 1
;;;359                }
;;;360            }
;;;361        }
;;;362    
;;;363        if(USART_GetIntBitState(USARTx_BASE, USART_INT_TBE) != RESET) {
000064  f2407427          MOV      r4,#0x727
000068  4621              MOV      r1,r4
00006a  4630              MOV      r0,r6
00006c  f7fffffe          BL       USART_GetIntBitState
000070  2800              CMP      r0,#0
000072  d01c              BEQ      |L1.174|
;;;364            USART_ClearIntBitState(USARTx_BASE, USART_INT_TBE);
000074  4621              MOV      r1,r4
000076  46b0              MOV      r8,r6
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       USART_ClearIntBitState
;;;365            cnt = read_available(&tx_buffer);
00007e  4812              LDR      r0,|L1.200|
000080  f7fffffe          BL       read_available
;;;366    
;;;367            if(cnt == 0) {
;;;368                USART_INT_Set(USARTx_BASE, USART_INT_TBE, DISABLE);
;;;369                tx_in_progress = 0;
000084  4e11              LDR      r6,|L1.204|
000086  b1a0              CBZ      r0,|L1.178|
;;;370            }
;;;371            else {
;;;372                USART_DataSend(USARTx_BASE, tx_buffer.data[tx_buffer.tail++]);
000088  4c0f              LDR      r4,|L1.200|
00008a  f8d40204          LDR      r0,[r4,#0x204]  ; tx_buffer
00008e  1821              ADDS     r1,r4,r0
000090  1c40              ADDS     r0,r0,#1
000092  f8c40204          STR      r0,[r4,#0x204]  ; tx_buffer
000096  7809              LDRB     r1,[r1,#0]
000098  4640              MOV      r0,r8
00009a  f7fffffe          BL       USART_DataSend
;;;373                if(tx_buffer.tail >= BUFFER_SIZE)
00009e  f8d40204          LDR      r0,[r4,#0x204]  ; tx_buffer
0000a2  42b8              CMP      r0,r7
0000a4  d301              BCC      |L1.170|
;;;374                    tx_buffer.tail = 0;
0000a6  f8c45204          STR      r5,[r4,#0x204]  ; tx_buffer
                  |L1.170|
;;;375                tx_in_progress = 1;
0000aa  2001              MOVS     r0,#1
0000ac  6030              STR      r0,[r6,#0]  ; tx_in_progress
                  |L1.174|
;;;376            }
;;;377        }
;;;378    }
0000ae  e8bd81f0          POP      {r4-r8,pc}
                  |L1.178|
0000b2  2200              MOVS     r2,#0                 ;368
0000b4  4621              MOV      r1,r4                 ;368
0000b6  4640              MOV      r0,r8                 ;368
0000b8  f7fffffe          BL       USART_INT_Set
0000bc  6035              STR      r5,[r6,#0]            ;369  ; tx_in_progress
0000be  e7f6              B        |L1.174|
                          ENDP

                  |L1.192|
                          DCD      0x40004400
                  |L1.196|
                          DCD      ||.bss||+0x208
                  |L1.200|
                          DCD      ||.bss||
                  |L1.204|
                          DCD      ||.data||

                          AREA ||i.clear_buffers||, CODE, READONLY, ALIGN=2

                  clear_buffers PROC
;;;92     
;;;93     static void clear_buffers(void)
000000  b570              PUSH     {r4-r6,lr}
;;;94     {
;;;95         memset((void *)&rx_buffer, 0xBB, sizeof(ring_buf_t));
000002  f44f7502          MOV      r5,#0x208
000006  22bb              MOVS     r2,#0xbb
000008  4629              MOV      r1,r5
00000a  480a              LDR      r0,|L2.52|
00000c  f7fffffe          BL       __aeabi_memset
;;;96         rx_buffer.head = 0;
000010  4808              LDR      r0,|L2.52|
000012  2400              MOVS     r4,#0
000014  f8c04200          STR      r4,[r0,#0x200]  ; rx_buffer
;;;97         rx_buffer.tail = 0;
000018  f8c04204          STR      r4,[r0,#0x204]  ; rx_buffer
;;;98         memset((void *)&tx_buffer, 0xBB, sizeof(ring_buf_t));
00001c  22bb              MOVS     r2,#0xbb
00001e  4629              MOV      r1,r5
000020  f5a07002          SUB      r0,r0,#0x208
000024  f7fffffe          BL       __aeabi_memset
;;;99         tx_buffer.head = 0;
000028  4803              LDR      r0,|L2.56|
00002a  f8c04200          STR      r4,[r0,#0x200]  ; tx_buffer
;;;100        tx_buffer.tail = 0;
00002e  f8c04204          STR      r4,[r0,#0x204]  ; tx_buffer
;;;101    }
000032  bd70              POP      {r4-r6,pc}
;;;102    
                          ENDP

                  |L2.52|
                          DCD      ||.bss||+0x208
                  |L2.56|
                          DCD      ||.bss||

                          AREA ||i.readAvailable||, CODE, READONLY, ALIGN=1

                  readAvailable PROC
;;;304    
;;;305    int16_t readAvailable(ring_buf_t *buffer)
000000  f8d01200          LDR      r1,[r0,#0x200]
;;;306    {
;;;307        return ((BUFFER_SIZE + buffer->head - buffer->tail) % BUFFER_SIZE);
000004  f8d00204          LDR      r0,[r0,#0x204]
000008  1a08              SUBS     r0,r1,r0
00000a  f3c00008          UBFX     r0,r0,#0,#9
;;;308    }
00000e  4770              BX       lr
;;;309    
                          ENDP


                          AREA ||i.read_available||, CODE, READONLY, ALIGN=1

                  read_available PROC
;;;76     
;;;77     static int16_t read_available(ring_buf_t *buffer)
000000  f8d01200          LDR      r1,[r0,#0x200]
;;;78     {
;;;79         return ((BUFFER_SIZE + buffer->head - buffer->tail) % BUFFER_SIZE);
000004  f8d00204          LDR      r0,[r0,#0x204]
000008  1a08              SUBS     r0,r1,r0
00000a  f3c00008          UBFX     r0,r0,#0,#9
;;;80     }
00000e  4770              BX       lr
;;;81     
                          ENDP


                          AREA ||i.uart_available||, CODE, READONLY, ALIGN=2

                  uart_available PROC
;;;332    
;;;333    uint32_t uart_available(void)
000000  4801              LDR      r0,|L5.8|
;;;334    {
;;;335        return readAvailable(&rx_buffer);
000002  f7ffbffe          B.W      readAvailable
;;;336    }
;;;337    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.bss||+0x208

                          AREA ||i.uart_get_configuration||, CODE, READONLY, ALIGN=2

                  uart_get_configuration PROC
;;;258    
;;;259    int32_t uart_get_configuration(UART_Configuration *config)
000000  4903              LDR      r1,|L6.16|
;;;260    {
;;;261        *config = configuration;
000002  e9d12101          LDRD     r2,r1,[r1,#4]
000006  e9c02100          STRD     r2,r1,[r0,#0]
;;;262    
;;;263        return 1;
00000a  2001              MOVS     r0,#1
;;;264    }
00000c  4770              BX       lr
;;;265    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      ||.data||

                          AREA ||i.uart_initialize||, CODE, READONLY, ALIGN=2

                  uart_initialize PROC
;;;102    
;;;103    int32_t uart_initialize(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;104    {
;;;105        uint16_t  data_bits;
;;;106        uint16_t  parity;
;;;107        uint16_t  stop_bits;
;;;108    
;;;109        GPIO_InitPara    GPIO_InitStructure;
;;;110        USART_InitPara   USART_InitStructure;
;;;111        NVIC_InitPara    NVIC_InitStructure;
;;;112    
;;;113        USARTx_CLOCK_ENABLE();
000004  2101              MOVS     r1,#1
000006  b086              SUB      sp,sp,#0x18           ;104
000008  0448              LSLS     r0,r1,#17
00000a  f7fffffe          BL       RCC_APB1PeriphClock_Enable
;;;114        USARTx_PINS_PORT_ENABLE();
00000e  2101              MOVS     r1,#1
000010  2004              MOVS     r0,#4
000012  f7fffffe          BL       RCC_APB2PeriphClock_Enable
;;;115    
;;;116        USART_INT_Set(USARTx_BASE, USART_INT_RBNE|USART_INT_TBE, DISABLE);
000016  4d45              LDR      r5,|L7.300|
000018  f2407827          MOV      r8,#0x727
00001c  2200              MOVS     r2,#0
00001e  4641              MOV      r1,r8
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       USART_INT_Set
;;;117        clear_buffers();
000026  f7fffffe          BL       clear_buffers
;;;118    
;;;119        // TX pin
;;;120        GPIO_InitStructure.GPIO_Pin   = USARTx_TX_PIN;
00002a  2404              MOVS     r4,#4
00002c  f8ad4000          STRH     r4,[sp,#0]
;;;121        GPIO_InitStructure.GPIO_Speed = GPIO_SPEED_50MHZ;
000030  2603              MOVS     r6,#3
000032  f88d6002          STRB     r6,[sp,#2]
;;;122        GPIO_InitStructure.GPIO_Mode  = GPIO_MODE_AF_PP;
000036  2018              MOVS     r0,#0x18
;;;123        GPIO_Init(USARTx_TX_PORT, &GPIO_InitStructure);
000038  4f3d              LDR      r7,|L7.304|
00003a  f88d0003          STRB     r0,[sp,#3]            ;122
00003e  4669              MOV      r1,sp
000040  4638              MOV      r0,r7
000042  f7fffffe          BL       GPIO_Init
;;;124        // RX pin
;;;125        GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
000046  2008              MOVS     r0,#8
000048  f8ad0000          STRH     r0,[sp,#0]
;;;126        GPIO_InitStructure.GPIO_Mode = GPIO_MODE_IN_FLOATING;
00004c  f88d4003          STRB     r4,[sp,#3]
;;;127        GPIO_Init(USARTx_RX_PORT, &GPIO_InitStructure);
000050  4669              MOV      r1,sp
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       GPIO_Init
;;;128        // CTS pin, input
;;;129        GPIO_InitStructure.GPIO_Pin = USARTx_CTS_PIN;
000058  2401              MOVS     r4,#1
00005a  f8ad4000          STRH     r4,[sp,#0]
;;;130        GPIO_InitStructure.GPIO_Mode = GPIO_MODE_IPU;
00005e  2048              MOVS     r0,#0x48
000060  f88d0003          STRB     r0,[sp,#3]
;;;131        GPIO_Init(USARTx_CTS_PORT, &GPIO_InitStructure);
000064  4669              MOV      r1,sp
000066  4638              MOV      r0,r7
000068  f7fffffe          BL       GPIO_Init
;;;132        // RTS pin, output low
;;;133        GPIO_InitStructure.GPIO_Pin = USARTx_RTS_PIN;
00006c  2002              MOVS     r0,#2
00006e  f8ad0000          STRH     r0,[sp,#0]
;;;134        GPIO_InitStructure.GPIO_Speed = GPIO_SPEED_50MHZ;
000072  f88d6002          STRB     r6,[sp,#2]
;;;135        GPIO_InitStructure.GPIO_Mode = GPIO_MODE_OUT_PP;
000076  2010              MOVS     r0,#0x10
000078  f88d0003          STRB     r0,[sp,#3]
;;;136        GPIO_Init(USARTx_RTS_PORT, &GPIO_InitStructure);
00007c  4669              MOV      r1,sp
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       GPIO_Init
;;;137        GPIO_ResetBits(USARTx_RTS_PORT, USARTx_RTS_PIN);
000084  2102              MOVS     r1,#2
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       GPIO_ResetBits
;;;138    
;;;139        // Only support 8bits
;;;140        data_bits = USART_WL_8B;
;;;141        // Parity
;;;142        if(configuration.Parity == UART_PARITY_ODD)
00008c  4e29              LDR      r6,|L7.308|
00008e  2300              MOVS     r3,#0                 ;140
000090  7970              LDRB     r0,[r6,#5]  ; configuration
000092  2801              CMP      r0,#1
000094  d03d              BEQ      |L7.274|
;;;143            parity = USART_PARITY_SETODD;
;;;144        else if(configuration.Parity == UART_PARITY_EVEN)
000096  2802              CMP      r0,#2
000098  d03e              BEQ      |L7.280|
;;;145            parity = USART_PARITY_SETEVEN;
;;;146        else
;;;147            parity = USART_PARITY_RESET;
00009a  2200              MOVS     r2,#0
                  |L7.156|
;;;148        // stop bits
;;;149        if(configuration.StopBits == UART_STOP_BITS_2)
00009c  79b0              LDRB     r0,[r6,#6]  ; configuration
00009e  2802              CMP      r0,#2
0000a0  d03d              BEQ      |L7.286|
;;;150            stop_bits = USART_STBITS_2;
;;;151        else if(configuration.StopBits == UART_STOP_BITS_1_5)
0000a2  2801              CMP      r0,#1
0000a4  d03e              BEQ      |L7.292|
;;;152            stop_bits = USART_STBITS_1_5;
;;;153        else
;;;154            stop_bits = USART_STBITS_1;
0000a6  2100              MOVS     r1,#0
                  |L7.168|
;;;155    
;;;156        // Configurate USARTx
;;;157        USART_InitStructure.USART_BRR = configuration.Baudrate;
0000a8  6830              LDR      r0,[r6,#0]  ; configuration
;;;158        USART_InitStructure.USART_WL = data_bits;
0000aa  9001              STR      r0,[sp,#4]
0000ac  f8ad3008          STRH     r3,[sp,#8]
;;;159        USART_InitStructure.USART_STBits = stop_bits;
;;;160        USART_InitStructure.USART_Parity = parity;
0000b0  f8ad200c          STRH     r2,[sp,#0xc]
;;;161        USART_InitStructure.USART_HardwareFlowControl = USART_HARDWAREFLOWCONTROL_NONE;
;;;162        USART_InitStructure.USART_RxorTx = USART_RXORTX_TX | USART_RXORTX_RX;
0000b4  200c              MOVS     r0,#0xc
0000b6  f8ad100a          STRH     r1,[sp,#0xa]          ;159
0000ba  2600              MOVS     r6,#0                 ;161
0000bc  f8ad000e          STRH     r0,[sp,#0xe]
0000c0  f8ad6010          STRH     r6,[sp,#0x10]         ;161
;;;163        USART_Init(USARTx_BASE, &USART_InitStructure);
0000c4  a901              ADD      r1,sp,#4
0000c6  4628              MOV      r0,r5
0000c8  f7fffffe          BL       USART_Init
;;;164        // Config NVIC
;;;165        NVIC_InitStructure.NVIC_IRQ = USARTx_IRQn;
0000cc  2026              MOVS     r0,#0x26
0000ce  f88d0014          STRB     r0,[sp,#0x14]
;;;166        NVIC_InitStructure.NVIC_IRQPreemptPriority = 0;
0000d2  f88d6015          STRB     r6,[sp,#0x15]
;;;167        NVIC_InitStructure.NVIC_IRQSubPriority = 0;
0000d6  f88d6016          STRB     r6,[sp,#0x16]
;;;168        NVIC_InitStructure.NVIC_IRQEnable = ENABLE;
0000da  f88d4017          STRB     r4,[sp,#0x17]
;;;169        NVIC_Init(&NVIC_InitStructure);
0000de  a805              ADD      r0,sp,#0x14
0000e0  f7fffffe          BL       NVIC_Init
;;;170        // Enable Rx interrupt
;;;171        USART_INT_Set(USARTx_BASE, USART_INT_RBNE, ENABLE);
0000e4  2201              MOVS     r2,#1
0000e6  f2405125          MOV      r1,#0x525
0000ea  4628              MOV      r0,r5
0000ec  f7fffffe          BL       USART_INT_Set
;;;172        // Disable Tx interrupt
;;;173        USART_INT_Set(USARTx_BASE, USART_INT_TBE, DISABLE);
0000f0  2200              MOVS     r2,#0
0000f2  4641              MOV      r1,r8
0000f4  4628              MOV      r0,r5
0000f6  f7fffffe          BL       USART_INT_Set
0000fa  490f              LDR      r1,|L7.312|
0000fc  2040              MOVS     r0,#0x40
0000fe  f8c10280          STR      r0,[r1,#0x280]
;;;174        // Clean all IT flag
;;;175        NVIC_ClearPendingIRQ(USARTx_IRQn);
;;;176        // Enable USARTx
;;;177        USART_Enable(USARTx_BASE, ENABLE);
000102  2101              MOVS     r1,#1
000104  4628              MOV      r0,r5
000106  f7fffffe          BL       USART_Enable
;;;178    
;;;179        return 1;
;;;180    }
00010a  b006              ADD      sp,sp,#0x18
00010c  2001              MOVS     r0,#1                 ;179
00010e  e8bd81f0          POP      {r4-r8,pc}
                  |L7.274|
000112  f44f62c0          MOV      r2,#0x600             ;143
000116  e7c1              B        |L7.156|
                  |L7.280|
000118  f44f6280          MOV      r2,#0x400             ;145
00011c  e7be              B        |L7.156|
                  |L7.286|
00011e  f44f5100          MOV      r1,#0x2000            ;150
000122  e7c1              B        |L7.168|
                  |L7.292|
000124  f44f5140          MOV      r1,#0x3000            ;152
000128  e7be              B        |L7.168|
;;;181    
                          ENDP

00012a  0000              DCW      0x0000
                  |L7.300|
                          DCD      0x40004400
                  |L7.304|
                          DCD      0x40010800
                  |L7.308|
                          DCD      ||.data||+0x4
                  |L7.312|
                          DCD      0xe000e004

                          AREA ||i.uart_read_data||, CODE, READONLY, ALIGN=2

                  uart_read_data PROC
;;;309    
;;;310    int32_t uart_read_data(uint8_t *data, uint16_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;311    {
000004  000d              MOVS     r5,r1
000006  4604              MOV      r4,r0
000008  d00b              BEQ      |L8.34|
;;;312        uint32_t cnt, len;
;;;313    
;;;314        if(size == 0)
;;;315            return 0;
;;;316    
;;;317        len = read_available(&rx_buffer);
00000a  4811              LDR      r0,|L8.80|
00000c  f7fffffe          BL       read_available
;;;318    		
;;;319        if(len > size)
000010  42a8              CMP      r0,r5
000012  d900              BLS      |L8.22|
;;;320            len = size;
000014  4628              MOV      r0,r5
                  |L8.22|
;;;321    		
;;;322    
;;;323        cnt = len;
000016  4603              MOV      r3,r0
000018  4a0d              LDR      r2,|L8.80|
;;;324        while(len--) {
;;;325            *data++ = rx_buffer.data[rx_buffer.tail++];
;;;326            if(rx_buffer.tail >= BUFFER_SIZE)
00001a  f44f7600          MOV      r6,#0x200
00001e  2500              MOVS     r5,#0
000020  e011              B        |L8.70|
                  |L8.34|
000022  2000              MOVS     r0,#0                 ;315
                  |L8.36|
;;;327                rx_buffer.tail = 0;
;;;328        }
;;;329    
;;;330        return cnt;
;;;331    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L8.40|
000028  f8d21204          LDR      r1,[r2,#0x204]        ;325  ; rx_buffer
00002c  1857              ADDS     r7,r2,r1              ;325
00002e  1c49              ADDS     r1,r1,#1              ;325
000030  f8c21204          STR      r1,[r2,#0x204]        ;325  ; rx_buffer
000034  7839              LDRB     r1,[r7,#0]            ;325
000036  f8041b01          STRB     r1,[r4],#1            ;325
00003a  f8d21204          LDR      r1,[r2,#0x204]        ;326  ; rx_buffer
00003e  42b1              CMP      r1,r6                 ;326
000040  d301              BCC      |L8.70|
000042  f8c25204          STR      r5,[r2,#0x204]        ;327  ; rx_buffer
                  |L8.70|
000046  1e40              SUBS     r0,r0,#1              ;327
000048  d2ee              BCS      |L8.40|
00004a  4618              MOV      r0,r3                 ;330
00004c  e7ea              B        |L8.36|
;;;332    
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      ||.bss||+0x208

                          AREA ||i.uart_reset||, CODE, READONLY, ALIGN=2

                  uart_reset PROC
;;;193    
;;;194    int32_t uart_reset(void)
000000  b510              PUSH     {r4,lr}
;;;195    {
;;;196        uart_initialize();
000002  f7fffffe          BL       uart_initialize
;;;197        tx_in_progress = 0;
000006  4902              LDR      r1,|L9.16|
000008  2000              MOVS     r0,#0
;;;198        return 1;
00000a  6008              STR      r0,[r1,#0]  ; tx_in_progress
00000c  2001              MOVS     r0,#1
;;;199    }
00000e  bd10              POP      {r4,pc}
;;;200    
                          ENDP

                  |L9.16|
                          DCD      ||.data||

                          AREA ||i.uart_set_configuration||, CODE, READONLY, ALIGN=2

                  uart_set_configuration PROC
;;;200    
;;;201    int32_t uart_set_configuration(UART_Configuration *config)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;202    {
;;;203        uint16_t data_bits;
;;;204        uint16_t parity;
;;;205        uint16_t stop_bits;
;;;206    
;;;207        USART_InitPara   USART_InitStructure;
;;;208    
;;;209        // Disable USARTx
;;;210        USART_Enable(USARTx_BASE, DISABLE);
000004  4d2a              LDR      r5,|L10.176|
000006  4604              MOV      r4,r0                 ;202
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       USART_Enable
;;;211        USART_INT_Set(USARTx_BASE, USART_INT_RBNE|USART_INT_TBE, DISABLE);
000010  f2407627          MOV      r6,#0x727
000014  2200              MOVS     r2,#0
000016  4631              MOV      r1,r6
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       USART_INT_Set
;;;212    
;;;213        clear_buffers();
00001e  f7fffffe          BL       clear_buffers
;;;214        // Only support 8bits
;;;215        data_bits = USART_WL_8B;
;;;216        configuration.DataBits = UART_DATA_BITS_8;
000022  4b24              LDR      r3,|L10.180|
000024  2008              MOVS     r0,#8
;;;217        // Parity
;;;218        configuration.Parity = config->Parity;
000026  2700              MOVS     r7,#0
000028  7118              STRB     r0,[r3,#4]            ;216
00002a  7960              LDRB     r0,[r4,#5]
00002c  7158              STRB     r0,[r3,#5]
;;;219        if(configuration.Parity == UART_PARITY_ODD)
00002e  2801              CMP      r0,#1
000030  d031              BEQ      |L10.150|
;;;220            parity = USART_PARITY_SETODD;
;;;221        else if(configuration.Parity == UART_PARITY_EVEN)
000032  2802              CMP      r0,#2
000034  d032              BEQ      |L10.156|
;;;222            parity = USART_PARITY_SETEVEN;
;;;223        else {
;;;224            parity = USART_PARITY_RESET;
000036  2200              MOVS     r2,#0
;;;225            configuration.Parity = UART_PARITY_NONE;
000038  715f              STRB     r7,[r3,#5]
                  |L10.58|
;;;226        }
;;;227        // stop bits
;;;228        configuration.StopBits = config->StopBits;
00003a  79a0              LDRB     r0,[r4,#6]
00003c  7198              STRB     r0,[r3,#6]
;;;229        if(configuration.StopBits == UART_STOP_BITS_2)
00003e  2802              CMP      r0,#2
000040  d02f              BEQ      |L10.162|
;;;230            stop_bits = USART_STBITS_2;
;;;231        else if(configuration.StopBits == UART_STOP_BITS_1_5)
000042  2801              CMP      r0,#1
000044  d030              BEQ      |L10.168|
;;;232            stop_bits = USART_STBITS_1_5;
;;;233        else {
;;;234            stop_bits = USART_STBITS_1;
000046  2000              MOVS     r0,#0
;;;235            configuration.StopBits = UART_STOP_BITS_1;
000048  719f              STRB     r7,[r3,#6]
                  |L10.74|
;;;236        }
;;;237        configuration.Baudrate = config->Baudrate;
00004a  6821              LDR      r1,[r4,#0]
;;;238        configuration.FlowControl = UART_FLOW_CONTROL_NONE;
00004c  6019              STR      r1,[r3,#0]  ; configuration
00004e  71df              STRB     r7,[r3,#7]
;;;239    
;;;240        // Configurate USARTx
;;;241        USART_InitStructure.USART_BRR = configuration.Baudrate;
;;;242        USART_InitStructure.USART_WL = data_bits;
000050  f8ad7004          STRH     r7,[sp,#4]
;;;243        USART_InitStructure.USART_STBits = stop_bits;
000054  f8ad0006          STRH     r0,[sp,#6]
;;;244        USART_InitStructure.USART_Parity = parity;
000058  f8ad2008          STRH     r2,[sp,#8]
;;;245        USART_InitStructure.USART_HardwareFlowControl = USART_HARDWAREFLOWCONTROL_NONE;
;;;246        USART_InitStructure.USART_RxorTx = USART_RXORTX_TX | USART_RXORTX_RX;
00005c  200c              MOVS     r0,#0xc
00005e  9100              STR      r1,[sp,#0]            ;242
000060  f8ad000a          STRH     r0,[sp,#0xa]
000064  f8ad700c          STRH     r7,[sp,#0xc]          ;245
;;;247        USART_Init(USARTx_BASE, &USART_InitStructure);
000068  4669              MOV      r1,sp
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       USART_Init
;;;248    
;;;249        // Enable Rx interrupt
;;;250        USART_INT_Set(USARTx_BASE, USART_INT_RBNE, ENABLE);
000070  2201              MOVS     r2,#1
000072  f2405125          MOV      r1,#0x525
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       USART_INT_Set
;;;251        // Disable Tx interrupt
;;;252        USART_INT_Set(USARTx_BASE, USART_INT_TBE, DISABLE);
00007c  2200              MOVS     r2,#0
00007e  4631              MOV      r1,r6
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       USART_INT_Set
;;;253        // Enable USARTx
;;;254        USART_Enable(USARTx_BASE, ENABLE);
000086  2101              MOVS     r1,#1
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       USART_Enable
;;;255    
;;;256        return 1;
;;;257    }
00008e  b004              ADD      sp,sp,#0x10
000090  2001              MOVS     r0,#1                 ;256
000092  e8bd81f0          POP      {r4-r8,pc}
                  |L10.150|
000096  f44f62c0          MOV      r2,#0x600             ;220
00009a  e7ce              B        |L10.58|
                  |L10.156|
00009c  f44f6280          MOV      r2,#0x400             ;222
0000a0  e7cb              B        |L10.58|
                  |L10.162|
0000a2  f44f5000          MOV      r0,#0x2000            ;230
0000a6  e7d0              B        |L10.74|
                  |L10.168|
0000a8  f44f5040          MOV      r0,#0x3000            ;232
0000ac  e7cd              B        |L10.74|
;;;258    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L10.176|
                          DCD      0x40004400
                  |L10.180|
                          DCD      ||.data||+0x4

                          AREA ||i.uart_uninitialize||, CODE, READONLY, ALIGN=2

                  uart_uninitialize PROC
;;;181    
;;;182    int32_t uart_uninitialize(void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184        // Disable USARTx
;;;185        USART_Enable(USARTx_BASE, DISABLE);
000002  4c07              LDR      r4,|L11.32|
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_Enable
;;;186        // Disable Tx interrupt
;;;187        USART_INT_Set(USARTx_BASE, USART_INT_TBE|USART_INT_RBNE, DISABLE);
00000c  2200              MOVS     r2,#0
00000e  f2407127          MOV      r1,#0x727
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_INT_Set
;;;188        // Clean buffers
;;;189        clear_buffers();
000018  f7fffffe          BL       clear_buffers
;;;190    
;;;191        return 1;
00001c  2001              MOVS     r0,#1
;;;192    }
00001e  bd10              POP      {r4,pc}
;;;193    
                          ENDP

                  |L11.32|
                          DCD      0x40004400

                          AREA ||i.uart_write_data||, CODE, READONLY, ALIGN=2

                  uart_write_data PROC
;;;270    
;;;271    int32_t uart_write_data(uint8_t *data, uint16_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;272    {
000004  000d              MOVS     r5,r1
000006  4604              MOV      r4,r0
000008  d00b              BEQ      |L12.34|
;;;273        uint32_t cnt, len;
;;;274    
;;;275        if(size == 0)
;;;276            return 0;
;;;277    
;;;278        len = write_available(&tx_buffer);
00000a  481f              LDR      r0,|L12.136|
00000c  f7fffffe          BL       write_available
;;;279        if(len > size)
000010  42a8              CMP      r0,r5
000012  d900              BLS      |L12.22|
;;;280            len = size;
000014  4628              MOV      r0,r5
                  |L12.22|
;;;281    		
;;;282    
;;;283        cnt = len;
000016  4680              MOV      r8,r0
;;;284        while(len--) {
;;;285            tx_buffer.data[tx_buffer.head++] = *data++;
;;;286            if(tx_buffer.head >= BUFFER_SIZE)
000018  f44f7700          MOV      r7,#0x200
00001c  2600              MOVS     r6,#0
00001e  4d1a              LDR      r5,|L12.136|
000020  e011              B        |L12.70|
                  |L12.34|
000022  2000              MOVS     r0,#0                 ;276
                  |L12.36|
;;;287                tx_buffer.head = 0;
;;;288        }
;;;289    
;;;290        if((!tx_in_progress)) {
;;;291            // Wait for tx is free
;;;292            //while(USART_GetITStatus(CDC_UART, USART_IT_TXE) == RESET);
;;;293    
;;;294            tx_in_progress = 1;
;;;295            USART_DataSend(USARTx_BASE, tx_buffer.data[tx_buffer.tail++]);
;;;296            if(tx_buffer.tail >= BUFFER_SIZE)
;;;297                tx_buffer.tail = 0;
;;;298            // Enale tx interrupt
;;;299            USART_INT_Set(USARTx_BASE, USART_INT_TBE, ENABLE);
;;;300        }
;;;301    
;;;302        return cnt;
;;;303    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L12.40|
000028  f8142b01          LDRB     r2,[r4],#1            ;285
00002c  f8d51200          LDR      r1,[r5,#0x200]        ;285  ; tx_buffer
000030  186b              ADDS     r3,r5,r1              ;285
000032  1c49              ADDS     r1,r1,#1              ;285
000034  f8c51200          STR      r1,[r5,#0x200]        ;285  ; tx_buffer
000038  701a              STRB     r2,[r3,#0]            ;285
00003a  f8d51200          LDR      r1,[r5,#0x200]        ;286  ; tx_buffer
00003e  42b9              CMP      r1,r7                 ;286
000040  d301              BCC      |L12.70|
000042  f8c56200          STR      r6,[r5,#0x200]        ;287  ; tx_buffer
                  |L12.70|
000046  1e40              SUBS     r0,r0,#1              ;287
000048  d2ee              BCS      |L12.40|
00004a  4810              LDR      r0,|L12.140|
00004c  6801              LDR      r1,[r0,#0]            ;290  ; tx_in_progress
00004e  b9c1              CBNZ     r1,|L12.130|
000050  2101              MOVS     r1,#1                 ;294
000052  6001              STR      r1,[r0,#0]            ;295  ; tx_in_progress
000054  f8d50204          LDR      r0,[r5,#0x204]        ;295  ; tx_buffer
000058  1829              ADDS     r1,r5,r0              ;295
00005a  1c40              ADDS     r0,r0,#1              ;295
00005c  f8c50204          STR      r0,[r5,#0x204]        ;295  ; tx_buffer
000060  7809              LDRB     r1,[r1,#0]            ;295
000062  4c0b              LDR      r4,|L12.144|
000064  4620              MOV      r0,r4                 ;295
000066  f7fffffe          BL       USART_DataSend
00006a  f8d50204          LDR      r0,[r5,#0x204]        ;296  ; tx_buffer
00006e  42b8              CMP      r0,r7                 ;296
000070  d301              BCC      |L12.118|
000072  f8c56204          STR      r6,[r5,#0x204]        ;297  ; tx_buffer
                  |L12.118|
000076  2201              MOVS     r2,#1                 ;299
000078  f2407127          MOV      r1,#0x727             ;299
00007c  4620              MOV      r0,r4                 ;299
00007e  f7fffffe          BL       USART_INT_Set
                  |L12.130|
000082  4640              MOV      r0,r8                 ;302
000084  e7ce              B        |L12.36|
;;;304    
                          ENDP

000086  0000              DCW      0x0000
                  |L12.136|
                          DCD      ||.bss||
                  |L12.140|
                          DCD      ||.data||
                  |L12.144|
                          DCD      0x40004400

                          AREA ||i.uart_write_free||, CODE, READONLY, ALIGN=2

                  uart_write_free PROC
;;;265    
;;;266    int32_t uart_write_free(void)
000000  4801              LDR      r0,|L13.8|
;;;267    {
;;;268        return write_available(&tx_buffer);
000002  f7ffbffe          B.W      write_available
;;;269    }
;;;270    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.bss||

                          AREA ||i.write_available||, CODE, READONLY, ALIGN=1

                  write_available PROC
;;;81     
;;;82     static int16_t write_available(ring_buf_t *buffer)
000000  f8d01204          LDR      r1,[r0,#0x204]
;;;83     {
;;;84         int16_t cnt;
;;;85     
;;;86         cnt = (buffer->tail - buffer->head - 1);
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  1a08              SUBS     r0,r1,r0
00000a  1e40              SUBS     r0,r0,#1
00000c  b200              SXTH     r0,r0
;;;87         if(cnt < 0)
00000e  2800              CMP      r0,#0
000010  da02              BGE      |L14.24|
000012  f5007000          ADD      r0,r0,#0x200          ;83
;;;88             cnt += BUFFER_SIZE;
000016  b200              SXTH     r0,r0
                  |L14.24|
;;;89     
;;;90         return cnt;
;;;91     }
000018  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tx_buffer
                          %        520
                  rx_buffer
                          %        520

                          AREA ||.data||, DATA, ALIGN=2

                  tx_in_progress
                          DCD      0x00000000
                  configuration
                          DCD      0x00002580
000008  08000000          DCB      0x08,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_deffd5cd____REV16|
#line 129 "..\\..\\cmsis-core\\core_cmInstr.h"
|__asm___6_uart_c_deffd5cd____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_deffd5cd____REVSH|
#line 144
|__asm___6_uart_c_deffd5cd____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
